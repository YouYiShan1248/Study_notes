# 1. 准备

## 1.1 项目描述

* 此项目为在线电商Web App (SPA)
* 包括首页, 搜索列表, 商品详情, 购物车, 订单, 支付, 用户登陆/注册等多个子模块
* 使用Vue全家桶+ES6++Webpack+Axios等前端最新最热的技术
* 采用模块化、组件化、工程化的模式开发



## 1.2 Vue插件或第三方库

* 学会使用**vue-router**开发单页应用
* 学会使用**axios**与后端进行数据交互
* 学会使用**vuex**管理应用组件状态
* 学会使用**swiper**实现页面滑动效果
* 学会使用**elment-ui**组件库构建界面
* 学会使用**vue-lazyload**实现图片惰加载
* 学会使用**mockjs**模拟后台数据接口





# 2. 应用开发详解

## 2.1 使用 Vue CLI 3(脚手架)搭建项目

Vue CLI是vue官方提供的用于搭建基于vue+webpack+es6项目的脚手架工具

操作:

```
# 使用vue-cli3
npm install -g @vue/cli
vue create shop-client
cd shop-client
npm run serve
```



编码测试与打包发布项目

* 编码测试

  ```
  npm run serve
  访问: http://localhost:8080
  编码, 自动编译打包(HMR), 查看效果
  ```

* 打包发布

  ```
  npm run build
  npm install -g serve
  serve dist -p 5000
  访问: http://localhost:5000
  ```

  



### **2.1.1 一些配置**

**src文件夹的别名的设置**

创建jsconfig.json文件（和vue.config.js 平级）

用@/代替src/，exclude表示不可以使用该别名的文件

```json
{
    "compilerOptions": {
        "baseUrl": "./",
        "paths": {
            "@/*": [
                "src/*"
            ]
        }
    },
    // 排除在 node_modules 和 dist 文件夹下
    "exclude": [
        "node_modules",
        "dist"
    ]
}
```





### 2.1.2 vue文件目录分析

**public文件夹**：静态资源，webpack进行打包的时候会原封不动打包到dist文件夹中。

**pubilc/index.html**：是一个模板文件，作用是生成项目的入口文件，webpack打包的js,css也会自动注入到该页面中。我们浏览器访问项目的时候就会默认打开生成好的index.html。

**src文件夹**（程序员代码文件夹）

> assets： 存放公用的静态资源
> components： 非路由组件（全局组件），其他组件放在views或者pages文件夹中
> app.vue： 唯一的根组件
> main.js： 程序入口文件，最先执行的文件

**babel.config.js**: 配置文件（babel相关）
**package.json**: 项目的详细信息记录
**package-lock.json**: 缓存性文件（各种包的来源）



### 2.1.3 清除vue页面默认的样式

vue是单页面开发，我们只需要修改public下的index.html文件

```html
<link rel="stylesheet" href="reset.css">
```





### 2.1.4 pages文件夹

创建pages文件夹，并创建路由组件
创建router文件夹，并创建index.js进行路由配置，最终在main.js中引入注册



**总结**
路由组件和非路由组件区别：

* 非路由组件放在components中，路由组件放在pages或views中
* 非路由组件通过标签使用，路由组件通过路由使用
* 在main.js注册完路由，所有的路由和非路由组件身上都会拥有$router $route属性
* $router：一般进行编程式导航进行路由跳转
* $route： 一般获取路由信息（name path params等）
  

路由跳转方式

- 声明式导航router-link标签 ,可以把router-link理解为一个a标签，它 也可以加class修饰
- 编程式导航 ：声明式导航能做的编程式都能做，而且还可以处理一些业务



## 2.2 ESLint

是一个代码检查工具

**规则的错误等级**

* 关闭规则检查 off。
* 打开规则检查，并且作为一个警告（输出提示文本黄色）warn。
* 打开规则检查，并且作为一个错误（输出提示文本红色）error。

**相关配置**

* package.json  全局规则配置文件

  ```json
  'rules': {
      'no-new': 'off',
      // 关闭缩进判断
      'indent': 'off',
      // 关闭分号判断
      'semi': [0],
      // 关闭冒号判断
      'singleQuote': [0]	
  }
  ```

* vue.config.js   关闭规则检查

  ```json
  // 关闭ESLint的规则
  lintOnSave: false,
  ```

  



## 2.3 引入 vue-router

**路由分析**

确定项目结构顺序:上中下 -----只有中间部分的V在发生变化，中间部分应该使用的是路由组件。

2个非路由组件|四个路由组件

两个非路由组件：Header 、Footer

路由组件:Home、Search、Login（没有底部的Footer组件，带有二维码的）、Register（没有底部的Footer组件，带二维码的）

**下载依赖**

`npm i vue-router@3.5.2`

**编码**

pages/Home/index.vue

```html
<template>
  <div>Home</div>
</template>

<script>
export default {
  name: 'Home',
  data () {
    return {}
  },
}
</script>

<style lang="less" scoped>

</style>
```

> 项目采用的less样式,浏览器不识别less语法，需要一些loader进行处理，把less语法转换为CSS语法
>
> npm i less@4.1.1
>
> npm i less-loader@5.0.0

> vue-cli3 帮我们把webpack简化了，原来需要在webpack中配置less-loader，在vue脚手架中就不需要了。



pages/Search/index.vue

```html
<template>
  <div>Search</div>
</template>

<script>
export default {
  name: 'Search',
  data () {
    return {}
  },
}
</script>

<style lang="less" scoped>

</style>
```

pages/Register/index.vue

```html
<template>
  <div>Register</div>
</template>

<script>
export default {
  name: 'Register',
  data () {
    return {}
  },
}
</script>

<style  lang="less" scoped>

</style>
```



pages/Login/index.vue

```html
<template>
  <div>Login</div>
</template>

<script>
export default {
  name: 'Login',
  data () {
    return {}
  },
}
</script>

<style  lang="less" scoped>
    
</style>
```



router/routes.js

```js
import Home from '@/pages/Home'
import Search from '@/pages/Search'
import Register from '@/pages/Register'
import Login from '@/pages/Login'

/* 
所有静态路由配置的数组
*/
export default [
  {
    path: '/',
    component: Home
  },

  {
    path: '/search',
    component: Search
  },

  {
    path: '/register',
    component: Register
  },

  {
    path: '/login',
    component: Login
  }
]
```



router/index.js

```js
import Vue from 'vue'
import VueRouter from 'vue-router'
import routes from './routes'

// 声明使用插件
Vue.use(VueRouter)
// 向外默认暴露路由器对象
export default new VueRouter({
  mode: 'history', // 没有#的模式
  routes, // 注册所有路由
})
```



main.js

```js
import Vue from 'vue'
import App from './App.vue'
import router from './router'

Vue.config.productionTip = false

new Vue({
  render: h => h(App),
  router, // 注册路由器
}).$mount('#app')
```



components/Header/index.vue

```html
<template>
  <div>Header</div>
</template>

<script>
export default {
  name: 'Header',
  data () {
    return {}
  },
}
</script>

<style  lang="less" scoped>

</style>
```



components/Footer/index.vue

```html
<template>
  <div>Footer</div>
</template>

<script>
export default {
  name: 'Footer',
  data () {
    return {}
  },
}
</script>

<style  lang="less" scoped>

</style>
```



App.vue

```html
<template>
  <div>
    <Header/>
    <router-view></router-view>
    <Footer/>
  </div>
</template>

<script>
import Header from './components/Header'
import Footer from './components/Footer'

export default {
  name: 'App',

  components: {
    Header,
    Footer
  }
}
</script>

<style lang="less" scoped>

</style>
```



**清除 vue 页面默认的样式**

public/css/reset.css

```css
/* 清除内外边距 */
body, h1, h2, h3, h4, h5, h6, hr, p, blockquote,
dl, dt, dd, ul, ol, li,
pre,
fieldset, lengend, button, input, textarea,
th, td {
    margin: 0;
    padding: 0;
}

/* 设置默认字体 */
body,
button, input, select, textarea { /* for ie */
    /*font: 12px/1 Tahoma, Helvetica, Arial, "宋体", sans-serif;*/
    font: 12px/1.3 "Microsoft YaHei",Tahoma, Helvetica, Arial, "\5b8b\4f53", sans-serif; /* 用 ascii 字符表示，使得在任何编码下都无问题 */
    color: #333;
}

h1 { font-size: 18px; /* 18px / 12px = 1.5 */ }
h2 { font-size: 16px; }
h3 { font-size: 14px; }
h4, h5, h6 { font-size: 100%; }

address, cite, dfn, em, var, i{ font-style: normal; } /* 将斜体扶正 */
b, strong{ font-weight: normal; } /* 将粗体扶细 */
code, kbd, pre, samp, tt { font-family: "Courier New", Courier, monospace; } /* 统一等宽字体 */
small { font-size: 12px; } /* 小于 12px 的中文很难阅读，让 small 正常化 */

/* 重置列表元素 */
ul, ol { list-style: none; }

/* 重置文本格式元素 */
a { text-decoration: none; color: #666;}

/* 重置表单元素 */
legend { color: #000; } /* for ie6 */
fieldset, img { border: none; }
button, input, select, textarea {
    font-size: 100%; /* 使得表单元素在 ie 下能继承字体大小 */
}

/* 重置表格元素 */
table {
    border-collapse: collapse;
    border-spacing: 0;
}

/* 重置 hr */
hr {
    border: none;
    height: 1px;
}
.clearFix::after{
    content:"";
    display: block;
    clear:both;
}
/* 让非ie浏览器默认也显示垂直滚动条，防止因滚动条引起的闪烁 */
html { overflow-y: scroll; }

a:link:hover{
    color : rgb(79, 76, 212) !important;
    text-decoration: underline;
}

/* 清除浮动 */
.clearfix::after {
    display: block;
    height: 0;
    content: "";
    clear: both;
    visibility: hidden;
}
```

vue是单页面开发，我们只需要修改public下的index.html文件

```html
<!-- 引入reset.css清除默认样式 -->
<link rel="stylesheet" href="./reset.css">
```





## 2.4 Header 组件



**template**

```html
<template>
  <header class="header">
    <!-- 头部的第一行 -->
    <div class="top">
      <div class="container">
        <div class="loginList">
          <p>尚品汇欢迎您！</p>
          <p>
            <span>请</span>
            <!-- 声明式路由 -->
            <router-link to="/login">登陆</router-link>
            <router-link class="register" to="/register">免费注册</router-link>
          </p>
        </div>
        <div class="typeList">
          <a href="javascript:">我的订单</a>
          <a href="javascript:">我的购物车</a>
          <a href="javascript:">我的尚品汇</a>
          <a href="javascript:">尚品汇会员</a>
          <a href="javascript:">企业采购</a>
          <a href="javascript:">关注尚品汇</a>
          <a href="javascript:">合作招商</a>
          <a href="javascript:">商家后台</a>
        </div>
      </div>
    </div>
    <!--头部第二行 搜索区域-->
    <div class="bottom">
      <h1 class="logoArea">
        <router-link class="logo" to="/">
          <img src="./images/logo.png" alt="logo" />
        </router-link>
      </h1>
      <div class="searchArea">
        <form class="searchForm">
          <input type="text" id="autocomplete" class="input-error input-xxlarge" v-model="keyword"/>
          <!-- 编程式路由 -->
          <button class="sui-btn btn-xlarge btn-danger" type="button" @click="search">搜索</button>
        </form>
      </div>
    </div>
  </header>
</template>

```



**script**

```html
<script>
  export default {
    name: "Header",
    data() {
      return {
        keyword: ''
      }
    },

    methods: {
      search () {
        this.$router.push(`/search/${this.keyword}`)
      }
    }
  }
</script>
```



**router/routes.js**

问题: 如何实现params参数可传可不传?

```json
{
    path: '/search/:keyword?', // params参数可传可不传
    component: Search
},
```





**Search 组件编码**

```html
<div>搜索关键字: {{$route.params.keyword}}</div>
```



### 路由跳转与传参相关问题

* 跳转路由的2种基本方式

  * 声明式: <router-link to="">
  * 编程式: this.$router.push() / replace()

* 跳转路由携带参数的2种方式

  * params参数：路由需要占位，属于URL当中一部分
  * query参数：路由不需要占位，写法类似于ajax当中query参数

  

**query、params两个属性可以传递参数**

> query参数：不属于路径当中的一部分，类似于get请求，地址栏表现为 /search?k1=v1&k2=v2
> query参数对应的路由信息 path: "/search"
> params参数：属于路径当中的一部分，需要注意，在配置路由的时候，需要占位 ,地址栏表现为 /search/v1/v2
> params参数对应的路由信息要修改为path: "/search/:keyword" 这里的/:keyword就是一个params参数的占位符



**传参方法**(同时传params参数和query参数)

* 字符串形式

  ```js
  this.$router.push("/search/"+ this.params传参 + "?k=" + this.query传参)
  ```

* 模板字符串

  ```js
  this.router.push("/search/+{this.params传参}?k=${this.query传参}")
  注意： 上面字符串的传参方法可以看出params参数和’/'结合，query参数和？结合
  http://localhost:8080/#/search/asd?keyword=asd
  上面url中asd为params的值，keyword=asd为query传递的值。
  ```

* 对象（常用）

  ```js
  this.$router.push({name:“路由名字”,params:{传参},query:{传参})。
  以对象方式传参时，如果我们传参中使用了params，只能使用name，不能使用path，如果只是使用query传参，可以使用path 。
  ```

​	



**params传参问题**

* 如何指定params参数可传可不传

  ```js
  如果路由path要求传递params参数,但是没有传递,会发现地址栏URL有问题，详情如下：
  Search路由项的path已经指定要传一个keyword的params参数，如下所示：
  path: "/search/:keyword",
  执行下面进行路由跳转的代码：
  this.$router.push({name:"Search",query:{keyword:this.keyword}}) // 此时params参数没有传
  当前跳转代码没有传递params参数
  地址栏信息：http://localhost:8080/#/?keyword=asd
  此时的地址信息少了/search
  正常的地址栏信息: http://localhost:8080/#/search?keyword=asd
  解决方法：可以通过改变path来指定params参数可传可不传 
  path: "/search/:keyword?",?表示该参数可传可不传
  ```

* 由（1）可知params可传可不传，但是如果传递的时空串，如何解决 。

  ```js
  this.$router.push({name:"Search",query:{keyword:this.keyword},params:{keyword:''}})
  出现的问题和1中的问题相同,地址信息少了/search
  解决方法： 加入||undefined，当我们传递的参数为空串时地址栏url也可以保持正常
  this.$router.push({name:"Search",query:{keyword:this.keyword},params:{keyword:''||undefined}})
  ```





**面试问题**

* 编程式路由跳转到当前路由(参数不变), 会抛出NavigationDuplicated的警告错误

  解决1：在跳转时指定成功或失败的回调函数, 通过catch处理错误

  解决2：修正Vue原型上的push和replace方法 (下面会详细说明)

* 如何指定params参数可传可不传? 

  答案：'/search/:keyword?'

* 指定params参数时可不可以用path和params配置的组合?

  答案：不可以用path和params配置的组合, 只能用name和params配置的组合。query配置可以与path或name进行组合使用（之前vue基础笔记提到过）

* 路由组件能不能传递props数据?

  可以: 可以将query或且params参数映射/转换成props传递给路由组件对象（之前vue基础笔记提到过）

  实现: props: (route)=>({keyword1:route.params.keyword, keyword2: route.query.keyword })



### （todo）**解决路由跳转时的NavigationDuplicated错误**

**将js的函数和promise复习后再看**

问题:

多次执行相同的push问题，控制台会出现错误

例如：使用`this.$router.push({name: 'search', query: {keyword: this.keyword.toUpperCase()}})`时，如果多次执行相同的push，控制台会出现错误。

```js
let result = this.$router.push({name: 'search', query: {keyword: this.keyword.toUpperCase()}})
console.log(result);
```

执行一次上面代码：

![在这里插入图片描述](https://img-blog.csdnimg.cn/d7b3e04b2986474d8009fe970b7b2e63.png)

多次执行出现错误：

![在这里插入图片描述](https://img-blog.csdnimg.cn/308f41adccfe4268a6a2e0b4b2d2cfd0.png)

原因分析：

vue-router3.1.0之后, 引入了push()的promise的语法,push是一个promise，promise需要传递成功和失败两个参数，我们的push中没有传递。

解决:

方案1：在进行跳转时, 指定跳转成功的回调函数或catch错误

```js
// catch()处理错误
this.$router.push(`/search/${this.keyword}`).catch(() => {})
// 指定成功的回调函数
this.$router.push(`/search/${this.keyword}`, () => {})
// 指定失败的回调函数
this.$router.push(`/search/${this.keyword}`, undefined, () => {})
```

方案2: 修正Vue原型上的push和replace方法

```js
// 缓存原型上的push函数
const originPush = VueRouter.prototype.push
const originReplace = VueRouter.prototype.replace
// 给原型对象上的push指定新函数函数
VueRouter.prototype.push = function (location, resolve, reject) {
    //函数对象的apply与call的区别?
    //相同点:都可以改变函数的上下文一次，而且函数会立即执行一次
    //不同：函数执行的时候，传递参数不同，apply需要的是数组，call传递参数的时候用逗号隔开
    //原始的push方法可以进行路由跳转，但是需要保证上下文this是VueRouter类的实例
    //第一种情况：外部在使用push的时候传递成功与失败的回调
    if (resolve && reject) {
         originPush.call(this, location, resolve, reject);
    } else {
         //第二种情况：外部在使用push方法的时候没有传递成功与失败的回调函数
         originPush.call(this, location, () => { }, () => { });
    }
}
//重写VueRouter.prototype.replace方法
VueRouter.prototype.replace = function (location, resolve, reject) {
    (resolve && reject) ? originReplace.call(this, location, resolve, reject) : originReplace.call(this, location, () => { }, () => { });
}
```



## 2.6 Footer 组件

**template**

```html
<template>
  <div class="footer">
    <div class="footer-container">
      <div class="footerList">
        <div class="footerItem">
          <h4>购物指南</h4>
          <ul class="footerItemCon">
            <li>购物流程</li>
            <li>会员介绍</li>
            <li>生活旅行/团购</li>
            <li>常见问题</li>
            <li>购物指南</li>
          </ul>

        </div>
        <div class="footerItem">
          <h4>配送方式</h4>
          <ul class="footerItemCon">
            <li>上门自提</li>
            <li>211限时达</li>
            <li>配送服务查询</li>
            <li>配送费收取标准</li>
            <li>海外配送</li>
          </ul>
        </div>
        <div class="footerItem">
          <h4>支付方式</h4>
          <ul class="footerItemCon">
            <li>货到付款</li>
            <li>在线支付</li>
            <li>分期付款</li>
            <li>邮局汇款</li>
            <li>公司转账</li>
          </ul>
        </div>
        <div class="footerItem">
          <h4>售后服务</h4>
          <ul class="footerItemCon">
            <li>售后政策</li>
            <li>价格保护</li>
            <li>退款说明</li>
            <li>返修/退换货</li>
            <li>取消订单</li>
          </ul>
        </div>
        <div class="footerItem">
          <h4>特色服务</h4>
          <ul class="footerItemCon">
            <li>夺宝岛</li>
            <li>DIY装机</li>
            <li>延保服务</li>
            <li>尚品汇E卡</li>
            <li>尚品汇通信</li>
          </ul>
        </div>
        <div class="footerItem">
          <h4>帮助中心</h4>
          <img src="./images/wx_cz.jpg">
        </div>
      </div>
      <div class="copyright">
        <ul class="helpLink">
          <li>关于我们
            <span class="space"></span>
          </li>
          <li>联系我们
            <span class="space"></span>
          </li>
          <li>关于我们
            <span class="space"></span>
          </li>
          <li>商家入驻
            <span class="space"></span>
          </li>
          <li>营销中心
            <span class="space"></span>
          </li>
          <li>友情链接
            <span class="space"></span>
          </li>
          <li>关于我们
            <span class="space"></span>
          </li>
          <li>营销中心
            <span class="space"></span>
          </li>
          <li>友情链接
            <span class="space"></span>
          </li>
          <li>关于我们</li>
        </ul>
        <p>地址：北京市昌平区宏福科技园综合楼6层</p>
        <p>京ICP备19006430号</p>
      </div>
    </div>
  </div>
</template>

<script>
  export default {
    name: 'Footer',
  }
</script>

<style lang="less" scoped>
  .footer {
    background-color: #eaeaea;

    .footer-container {
      width: 1200px;
      margin: 0 auto;
      padding: 0 15px;

      .footerList {
        padding: 20px;
        border-bottom: 1px solid #e4e1e1;
        border-top: 1px solid #e4e1e1;
        overflow: hidden;
        padding-left: 40px;

        .footerItem {
          width: 16.6666667%;
          float: left;

          h4 {
            font-size: 14px;
          }

          .footerItemCon {
            li {
              line-height: 18px;
            }
          }

          &:last-child img {
            width: 121px;
          }
        }
      }

      .copyright {
        padding: 20px;

        .helpLink {
          text-align: center;

          li {
            display: inline;

            .space {
              border-left: 1px solid #666;
              width: 1px;
              height: 13px;
              background: #666;
              margin: 8px 10px;
            }
          }
        }

        p {
          margin: 10px 0;
          text-align: center;
        }
      }
    }
  }
</style>
```



**控制Footer界面的显示/隐藏**

解决方案: 利用路由的meta（路由元信息）配置和v-show



**router/routes.js**

```json
{
  path: '/register',
  component: Register,
  meta: { // 需要隐藏footer的路由添加此配置
    show: false
  }
},

{
  path: '/login',
  component: Login,
  meta: {
    isHideFooter: true
  }
},
```



**App.vue**

```html
<Footer v-show="$route.meta.show"></Footer>
```





## 2.7 Home路由组件

### 从Home组件中抽取子组件(静态)

* TypeNav: 3级分类导航
* ListContainer: 包含轮播列表的容器
* TodayRecommend: 今日推荐
* Rank: 排行
* Like: 猜你喜欢
* Floor: 楼层
* Brand: 品牌



### 定义三级联动全局组件

我们的三级联动组件是全局组件，全局的配置都需要在main.js中配置

```js
//将三级联动组件注册为全局组件
import TypeNav from '@/pages/Home/TypeNav';
//第一个参数：全局组件名字，第二个参数：全局组件
Vue.component(TypeNav.name,TypeNav);
```

> 全局组件可以在任一页面中直接使用，不需要导入声明



在Home组件中使用该全局组件

```html
<template>
<div>
<!--  三级联动全局组件已经注册为全局组件，因此不需要引入-->
  <TypeNav/>
</div>
</template>
```

全局组件可以在任一页面中直接使用，不需要导入声明
下面全部商品分类就是三级联动组件

![在这里插入图片描述](https://img-blog.csdnimg.cn/08961e311d8a40f9b4f6298e0099cc19.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5q-b5q-b6Jmr5ZGc5ZGc,size_20,color_FFFFFF,t_70,g_se,x_16)





### 代码改变时实现页面自动刷新

根目录下vue.config.js文件设置

```js
module.exports = {
    //关闭eslint
    lintOnSave: false,
    devServer: {
        // true 则热更新，false 则手动刷新，默认值为 true
        inline: true,
        // development server port 8000
        port: 8001,

    }
}
```

> 注意：修改完该配置文件后，要重启一下项目
>
> 动了配置文件都要重启



## 2.8 封装axios和进度条

**下载依赖包**

`npm install axios@0.21.1`

`npm install nprogress@0.2.0`

**api/ajax.js**

```js
/* 
对axios进行二次包装
1. 配置通用的基础路径和超时
2. 显示请求进度条
3. 成功返回的数据不再是response, 而直接是响应体数据response.data
4. 统一处理请求错误, 具体请求也可以选择处理或不处理
*/
import axios from 'axios'
import NProgress from 'nprogress'
// 引入进度条样式
import 'nprogress/nprogress.css'

// 配置不显示右上角的旋转进度条, 只显示水平进度条
NProgress.configure({ showSpinner: false }) 

//创建axios实例[创建出来的实例即为axios，只不过可以配置一些东西]
const service = axios.create({
  baseURL: "/api", // 基础路径
  timeout: 15000   // 连接请求超时时间
})

//请求拦截器:在发请求之前可以检测到，可以干一些事情
service.interceptors.request.use((config) => {
  // 显示请求中的水平进度条
  NProgress.start()

  // 必须返回配置对象
  return config
})

//响应拦截器：服务器的数据已经返回了，可以干一些事情
service.interceptors.response.use((response) => {
  // 隐藏进度条
  NProgress.done()
  // 返回响应体数据
  return response.data
}, (error) => {
  // 隐藏进度条
  NProgress.done()

  // 统一处理一下错误
  alert( `请求出错: ${error.message||'未知错误'}`)

  // 后面可以选择不处理或处理
  return Promise.reject(error)
})

//对外暴露二次封装的axios
export default service
```



**api/index.js**

```js
/* 
包含所有接口请求函数的模块
*/
import ajax from './ajax'

//获取商品的三级分类列表
export const reqCategoryList = () => ajax.get('/product/getBaseCategoryList')
```





**App.vue**

```js
import {reqCategoryList} from '@/api'

async mounted () {
    const result = await reqBaseCategoryList()
    console.log('result', result)
},
```



### 前端通过代理解决跨域问题

在根目录下的 vue.config.js 中配置, proxy 为通过代理解决跨域问题。
我们在封装 axios 的时候已经设置了 baseURL 为 api ,所以所有的请求都会携带 /api，这里我们就将 /api 进行了转换。如果你的项目没有封装 axios，或者没有配置baseURL，建议进行配置。要保证baseURL和这里的代理映射相同，此处都为’/api’。



**vue.config.js**

```json
module.exports = {
    //关闭eslint
    lintOnSave: false,
    devServer: {
        // true 则热更新，false 则手动刷新，默认值为 true
        inline: false,
        // development server port 8000
        port: 8001,
        //代理服务器解决跨域
        proxy: {
            //会把请求路径中的/api换为后面的代理服务器
            '/api': {
                //提供数据的服务器地址
                target: 'http://39.98.123.211',

            }
        },
    }
}
```





## 2.12 使用vuex管理状态

**下载依赖包**

`npm i vuex@3.6.2`



**store/modules/home.js**

```js
/* 
vuex管理的home模块
*/
import {reqCategoryList} from '@/api'

const state = {
  baseCategoryList: [], // 所有分类的数组
}

const mutations = {
  /* 
  接收保存分类列表
  */
  RECEIVE_BASE_CATEGORY_LIST(state, list) {
    state.baseCategoryList = list
  }
}

const actions = {
  /* 
  异步获取商品三级分类列表
  */
  async getBaseCategoryList({ commit }) {
    const result = await reqBaseCategoryList();
    if (result.code === 200) {
      commit('RECEIVE_BASE_CATEGORY_LIST', result.data)
    }
  },
}

const getters = {

}

export default {
  state,
  actions,
  mutations,
  getters
}

```



**store/modules/index.js**

```js
/* 
收集所有vuex管理的模块
*/
import home from './home'
// 向外暴露包含所有vuex管理的模块的对象
export default{
  home,
}
```





**store/index.js**

```js
/* 
Vuex最核心的管理对象store
*/
import Vue from 'vue'
import Vuex from 'vuex'
import modules from './modules'

// 声明使用vuex插件
Vue.use(Vuex)

// 向外暴露store对象
export default new Vuex.Store({
  modules, // 配置store的所有模块
})

```



**注册store**

**main.js**

```js
import store from './store'

new Vue({
  store, // 注册vuex的store对象  ==> 所有组件对象都有一个$store属性
})
```





## 2.13 异步显示分类列表: TypeNav

> 重难点说明

### 组件与vuex交互

```html
<template>
  <div class="type-nav">
    <div class="container">
      <h2 class="all">全部商品分类</h2>
      <nav class="nav">
        <a href="###">服装城</a>
        <a href="###">美妆馆</a>
        <a href="###">尚品汇超市</a>
        <a href="###">全球购</a>
        <a href="###">闪购</a>
        <a href="###">团购</a>
        <a href="###">有趣</a>
        <a href="###">秒杀</a>
      </nav>
      <div class="sort" v-if="isShow">
        <div class="all-sort-list2">
          <div class="item" v-for="(c1, index) in baseCategoryList" :key="c1.categoryId">
            <h3>
              <a href="">{{c1.categoryName}}</a>
            </h3>
            <div class="item-list clearfix">
              <div class="subitem" v-for="(c2, index) in c1.categoryChild" :key="c2.categoryId">
                <dl class="fore">
                  <dt>
                    <a>{{c2.categoryName}}</a>
                  </dt>

                  <dd>
                    <em v-for="(c3, index) in c2.categoryChild" :key="c3.categoryId">
                      <a href="">{{c3.categoryName}}</a>
                    </em>
                  </dd>
                </dl>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
  import { mapState } from 'vuex'
  export default {
    name: 'TypeNav',
    mounted () {
      // 通知vuex发请求，获取数据，存储于仓库中
      this.$store.dispatch('getBaseCategoryList');
    },

    computed: {
      ...mapState({
        // 右侧需要的是一个函数，当使用这个计算属性的时候，右侧函数会立即执行一次
        // 注入一个参数state，其实即为大仓库中的数据
        baseCategoryList: state => state.home.baseCategoryList
      })
    },
  }
</script>
```



### 事件控制二三级分类列表的显示与隐藏

通过 vue 绑定样式来控制我们想要的样式 

> :class="{}"                  :style="{}"

```html
<template>
  <!-- 商品分类导航 -->
  <div class="type-nav">
    <div class="container">
      <!-- 使用事件委托 -->
      <div @mouseleave="leaveIndex">
        <h2 class="all">全部商品分类</h2>
        <div class="sort">
        <div class="all-sort-list2">
          <div class="item" v-for="(c1, index) in categoryList" :key="c1.categoryId" :class="{cur: currentIndex == index}">
            <h3 @mouseenter="changeIndex(index)">
              <a href="">{{c1.categoryName}}</a>
            </h3>
            <div class="item-list clearfix" :style="{display: currentIndex == index? 'block' : 'none'}">
              <div class="subitem" v-for="(c2,index) in c1.categoryChild" :key="c2.categoryId">
                <dl class="fore">
                  <dt>
                    <a href="">{{c2.categoryName}}</a>
                  </dt>
                  <dd>
                    <em v-for="(c3,index) in c2.categoryChild" :key="c3.categoryId">
                      <a href="">{{c3.categoryName}}</a>
                    </em>
                  </dd>
                </dl>
              </div>
            </div>
          </div>
        </div>
      </div>
      </div>
    </div>
  </div>
</template>

<script>
//vuex辅助函数mapState获取仓库数据
import { mapState } from "vuex";
export default {
  name: "TypeNav",
  data () {
    return {
      currentIndex: -1,
    }
  },
  methods: {
    // 控制一级菜单的背景
    changeIndex(index) {
      this.currentIndex = index;
    },
    // 控制一级菜单的背景
    leaveIndex() {
      this.currentIndex = -1;
    }
  }
};
</script>

```



### 优化高频事件触发处理: 利用lodash进行函数节流处理

在进行窗口的resize、scroll，输入框内容校验等操作时，如果事件处理函数调用的频率无限制，会加重浏览器的负担，导致用户体验非常糟糕。此时我们可以采用debounce（防抖）和throttle（节流）的方式来减少调用频率，同时又不影响实际效果。

防抖：前面的所有的触发都被取消，最后一次执行在规定的时间之后才会触发，也就是说如果连续快速的触发,只会执行最后一次

节流：在规定的间隔时间范围内不会重复触发回调，只有大于这个时间间隔才会触发回调，把频繁触发变为少量触发

**三级联动用节流优化**

```js
//按需引入：只是把需要的功能引入进来
// lodash 不需要 npm ，因为 lodash 是脚手架需要的工具，会提前下载
import throttle from "lodash/throttle";

methods: {
    //h3的鼠标移入事件:用户行为如果过快，会出现浏览器反应不过来的现象----【用户行为太快】
    //回调函数里面业务代码很多，卡顿、业务没有完整完成。
    changeIndex: throttle(function(index) {
      //修改当前currentIndex索引值
      //函数节流:在50MS时间之内只能执行一次
      this.currentIndex = index;
    }, 50)
}
```

### 优化减少组件对象数量: 使用编程式导航代替声明式导航

如上图所示，三级标签列表有很多，每一个标签都是一个页面链接，我们要实现通过点击表现进行路由跳转。
路由跳转的两种方法：导航式路由，编程式路由。

> 对于导航式路由，我们有多少个a标签就会生成多少个router-link标签，router-link是一个组件：相当于VueComponent类的实例对象，一瞬间new VueComponent很多实例（1000+），很消耗内存，因此导致卡顿。
> 对于编程式路由，我们是通过触发点击事件实现路由跳转。同理有多少个a标签就会有多少个触发函数。虽然不会出现卡顿，但是也会影响性能。

上面两种方法无论采用哪一种，都会影响性能。我们提出一种：编程时导航+事件委派 的方式实现路由跳转。事件委派即把子节点的触发事件都委托给父节点。这样只需要一个回调函数goSearch就可以解决。

**事件委派问题：**

（1）如何确定我们点击的一定是a标签呢？如何保证我们只能通过点击a标签才跳转呢？
（2）如何获取子节点标签的商品名称和商品id(**我们是通过商品名称和商品id进行页面跳转的**)

**解决方法：**

对于问题1：为三个等级的a标签添加自定义属性date-categoryName绑定商品标签名称来标识a标签（其余的标签是没有该属性的）。

对于问题2：为三个等级的a标签再添加自定义属性data-category1Id、data-category2Id、data-category3Id来获取三个等级a标签的商品id，用于路由跳转。

我们可以通过在函数中传入event参数，获取当前的点击事件，通过event.target属性获取当前点击节点，再通过dataset属性获取节点的属性信息。

**template**

```html
<template>
  <!-- 商品分类导航 -->
  <div class="type-nav">
    <div class="container">
      <!-- 使用事件委托 -->
      <div @mouseleave="leaveIndex">
        <h2 class="all">全部商品分类</h2>
        <div class="sort">
          <div class="all-sort-list2" @click="goSearch">
            <div
              class="item"
              v-for="(c1, index) in categoryList"
              :key="c1.categoryId"
              :class="{ cur: currentIndex == index }"
            >
              <h3 @mouseenter="changeIndex(index)">
                <a
                  :data-categoryName="c1.categoryName"
                  :data-category1Id="c1.categoryId"
                  >{{ c1.categoryName }}</a
                >
              </h3>
              <div
                class="item-list clearfix"
                :style="{ display: currentIndex == index ? 'block' : 'none' }"
              >
                <div
                  class="subitem"
                  v-for="(c2, index) in c1.categoryChild"
                  :key="c2.categoryId"
                >
                  <dl class="fore">
                    <dt>
                      <a
                        :data-categoryName="c2.categoryName"
                        :data-category2Id="c2.categoryId"
                        >{{ c2.categoryName }}</a
                      >
                    </dt>
                    <dd>
                      <em
                        v-for="(c3, index) in c2.categoryChild"
                        :key="c3.categoryId"
                      >
                        <a
                          :data-categoryName="c3.categoryName"
                          :data-category3Id="c3.categoryId"
                          >{{ c3.categoryName }}</a
                        >
                      </em>
                    </dd>
                  </dl>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>
```

对应的goSearrch函数

```js
//编程式导航按钮的回调函数
goSearch(event) {  
    //点击a标签进行路由跳转：父节点代理的子节点的类型很多 div h3 dd dt em a
    //通过event可以获取到当前触发事件的节点
    let nodeElement = event.target;
    //给a标签添加自定义属性data-categoryName，保证这个节点带data-categoryName，一定是a标签
    //可以通过节点的dataset属性获取相应节点的自定义属性，返回的是一个对象KV【自定义属性相关的】
    //如果带有categoryname字段的一定是a标签
    //html中会把大写转为小写
    // 所以 categoryname，category1id 这些都是小写
    let { categoryname, category1id, category2id, category3id } =
        nodeElement.dataset;
    //执行if语句：只能区分点击的标签是不是a
    if (categoryname) {
        //准备路由跳转的参数
        let location = { name: "search" };
        let query = { categoryName: categoryname };
        //一级分类的a标签
        if (category1id) {
            query.category1Id = category1id;
            //二级分类的a标签
        } else if (category2id) {
            query.category2Id = category2id;
            //三级分类a标签
        } else {
            query.category3Id = category3id;
        }
        //路由跳转之前：看一下有没有params参数，如果有params参数需要携带给search
        if (this.$route.params) {
            //query参数
            location.query = query;
            //params
            location.params = this.$route.params;
            //如有有params参数也需要携带给search模块
            //home->search确实需要记录历史
            //search->search不需要存储历史记录
            if (this.$route.path != "/home") {
                this.$router.replace(location);
            } else {
                this.$router.push(location);
            }
        }
    }
}
```

### 控制一级列表的显示与隐藏和动画过渡效果

使用 v-show 来控制一级列表的显示与隐藏，使用事件委托统一控制mouseleave 和 mouseenter事件

**template**

```html
<template>
  <!-- 商品分类导航 -->
  <div class="type-nav">
    <div class="container">
      <!-- 使用事件委托 -->
      <div @mouseleave="leaveShow" @mouseenter="enterShow">
        <h2 class="all">全部商品分类</h2>
        <transition name="sort">
          <div class="sort" v-show="show">
            <div class="all-sort-list2" @click="goSearch">
            ....
            </div>
          </div>
        </transition>
      </div>
      
    </div>
  </div>
</template>

<script>
//按需引入：只是把需要的功能引入进来
// lodash 不需要 npm ，因为 lodash 是脚手架需要的工具，会提前下载
import throttle from "lodash/throttle";
//vuex辅助函数mapState获取仓库数据
import { mapState } from "vuex";
export default {
  name: "TypeNav",
  data() {
    return {
      currentIndex: -1,
      show: true,
    };
  },
  mounted() {
    // 通知vuex发请求，获取数据，存储于仓库中
    console.log(this.$route.path);
    this.$store.dispatch("getCategory");
    //如果不是Home路由组件，将typeNav进行隐藏
    if (this.$route.path != "/home") {
      this.show = false;
    }
  },
  methods: {
    //当鼠标离开的时候，让商品分类列表进行隐藏
    leaveShow() {
      this.currentIndex = -1;
      //判断如果是Search路由组件的时候才会执行
      if (this.$route.path != "/home") {
        this.show = false;
      }
    },
    //当鼠标移入的时候，让商品分类列表进行展示
    enterShow() {
      if (this.$route.path != "/home") {
        this.show = true;
      }
    },
  },
};
</script>

<style scoped lang="less">
.type-nav {
  border-bottom: 2px solid #e1251b;

  .container {
    width: 1200px;
    margin: 0 auto;
    display: flex;
    position: relative;

    .sort {
      ...
    }
    //过渡动画的样式
    //过渡动画开始状态（进入）
    .sort-enter {
      height: 0px;
    }
    // 过渡动画结束状态（进入）
    .sort-enter-to {
      height: 461px;
    }
    // 定义动画时间、速率
    .sort-enter-active {
      transition: all 0.5s linear;
    }
  }
}
</style>
```

### 优化请求执行的位置, 减少请求次数

**Vue在路由切换的时候会销毁旧路由**。

我们在三级列表全局组件TypeNav中的mounted进行了请求一次商品分类列表数据。

由于**Vue在路由切换的时候会销毁旧路由**，当我们再次使用三级列表全局组件时还会发一次请求。

如下图所示：当我们在包含三级列表全局组件的不同组件之间进行切换时，都会进行一次信息请求。

由于信息都是一样的，出于性能的考虑我们希望该数据只请求一次，所以我们把这次请求放在App.vue的mounted中。（根组件App.vue的mounted只会执行一次）

### 合并分类query参数与搜索的关键字params参数

两种情况：

先点 typeNav（传的是query参数），再点搜索键（传的是params参数），这时要再 Header.vue 中进行处理，有 query参数的话要带上。

```js
goSearch() {
    //代表的是如果有query参数也带过去
    if (this.$route.query) {
        let loction = {
            name: "search",
            params: { keyword: this.keyword || undefined },
        };
        loction.query = this.$route.query;
        this.$router.push(loction);
    }
}
```

先点搜索键（传的是params参数），后点 typeNav（传的是query参数），这时要在 TypeNav.vue 中处理，有 params参数的话要带上。

```js
goSearch(event) {
    //点击a标签进行路由跳转：父节点代理的子节点的类型很多 div h3 dd dt em a
    //通过event可以获取到当前触发事件的节点
    let nodeElement = event.target;
    //给a标签添加自定义属性data-categoryName，保证这个节点带data-categoryName，一定是a标签
    //可以通过节点的dataset属性获取相应节点的自定义属性，返回的是一个对象KV【自定义属性相关的】
    //如果带有categoryname字段的一定是a标签
    //html中会把大写转为小写
    // 所以 categoryname，category1id 这些都是小写
    let { categoryname, category1id, category2id, category3id } =
        nodeElement.dataset;
    //执行if语句：只能区分点击的标签是不是a
    if (categoryname) {
        //准备路由跳转的参数
        let location = { name: "search" };
        let query = { categoryName: categoryname };
        //一级分类的a标签
        if (category1id) {
            query.category1Id = category1id;
            //二级分类的a标签
        } else if (category2id) {
            query.category2Id = category2id;
            //三级分类a标签
        } else {
            query.category3Id = category3id;
        }
        //路由跳转之前：看一下有没有params参数，如果有params参数需要携带给search
        if (this.$route.params) {
            //query参数
            location.query = query;
            //params
            location.params = this.$route.params;
            //如有有params参数也需要携带给search模块
            //home->search确实需要记录历史
            //search->search不需要存储历史记录
            if (this.$route.path != "/home") {
                this.$router.replace(location);
            } else {
                this.$router.push(location);
            }
        }
    }
},
```



## 2.14 Mock/模拟数据接口

**下载依赖包**

`npm i mockjs@1.1.0`

**mockjs提供模拟数据**

mock/mockServe.js

```js
//先引入mockjs模块
import Mock from 'mockjs';
//把JSON数据格式引入进来[JSON数据格式根本没有对外暴露，但是可以引入]
//webpack默认对外暴露的：图片、JSON数据格式
import banner from './banner.json';
import floor from './floor.json';


//mock数据:第一个参数请求地址   第二个参数：请求数据
Mock.mock("/mock/banner", { code: 200, data: banner });//模拟首页大的轮播图的数据
Mock.mock("/mock/floor", { code: 200, data: floor });
```



**api/ajaxMock.js**

```js
//对于axios进行二次封装
import axios from "axios";
import nprogress from "nprogress";
//如果出现进度条没有显示：一定是你忘记了引入样式了
import "nprogress/nprogress.css";
//底下的代码也是创建axios实例
let requests = axios.create({
  //基础路径
  baseURL: "/mock",
  //请求不能超过5S
  timeout: 5000,
});

//请求拦截器----在项目中发请求（请求没有发出去）可以做一些事情
requests.interceptors.request.use((config) => {
  //现在的问题是config是什么?配置对象
  //可以让进度条开始动
  nprogress.start();
  return config;
});

//响应拦截器----当服务器手动请求之后，做出响应（相应成功）会执行的
requests.interceptors.response.use(
  (res) => {
    //进度条结束
    nprogress.done();
    //相应成功做的事情
    return res.data;
  },
  (err) => {
    alert("服务器响应数据失败");
  }
);
//最终需要对外暴露（不对外暴露外面模块没办法使用）
//这里的代码是暴露一个axios实例
export default requests;

```



**api/index.js**

```js
import mockRequests from "./ajaxMock";
//获取banner（Home首页轮播图接口）
export const reqGetBannerList = () => mockRequest({ url: '/banner', method: 'get' });
//获取floor数据
export const reqFloorList = () => mockRequest({ url: '/floor', method: 'get' });
```



**将请求来的数据存储到 vuex 中**

store/home/index.js

```js
//home模块的小仓库
import { reqCategoryList, reqGetBannerList, reqFloorList } from '@/api';
//四大核心属性
//state：仓库数据的来源
const state = {
    //商品分类的数据,这里初始化数据不能瞎写。看请求返回的结果
    categoryList: [],
    //轮播图的数据
    bannerList: [],
    //floor组件的数据
    floorList: []
};
//mutations:唯一可以改变state数据地方
const mutations = {
    GETCATEGORY(state, category) {
        //修改state
        state.categoryList = category;
    },
    GETBANNERLIST(state, bannerList) {
        state.bannerList = bannerList;
    },
    GETFLOORLIST(state, floorList) {
        state.floorList = floorList;
    }
}
//actions:可以处理dispatch派发action地方，这里可以书写你的业务逻辑：for、if、异步语句等等
const actions = {
    //获取商品分类的数据
    async getCategory({ commit }) {
        let result = await reqCategoryList();
        // console.log(result);
        if (result.code === 200) {
            //提交mutation
            commit("GETCATEGORY", result.data);
        }
    },
    //获取首页轮播图的数据
    async getBannerList({ commit }) {
        let result = await reqGetBannerList();
        if (result.code == 200) {
            commit("GETBANNERLIST", result.data);
        }
    },
    //获取floor数据
    async getFloorList({ commit }) {
        let result = await reqFloorList();
        if (result.code == 200) {
            //提交mutation
            commit("GETFLOORLIST", result.data);
        }
    },
}
//getters：计算属性
const getters = {};
export default {
    state,
    mutations,
    actions,
    getters
}
```

轮播图组件ListContainer.vue组件在store中获取轮播图数据。由于在这个数据是通过异步请求获得的，所以我们要通过计算属性computed获取轮播图数据。

**ListContainer.vue代码**

```js
 <script>
import {mapState} from "vuex";
export default {
  name: "index",
  //主键挂载完毕，请求轮播图图片
  mounted() {
    this.$store.dispatch("getBannerList")
  },
  computed:{
    ...mapState({
      bannerList: (state) => state.home.bannerList
    })
  }
}
</script>
```



**main.js**

```js
//引入MockServer.js----mock数据
import "@/mock/mockServe";
```



> 把mock数据需要的图片放置于public文件夹中！比如:listContainer中的轮播图的数据。
>
> public文件夹在打包的时候，会把相应的资源原封不动打包到dist文件夹中



## 2.15 swiper插件实现轮播图

> （1）安装swiper
> （2）在需要使用轮播图的组件内导入swpier和它的css样式
> （3）在组件中创建swiper需要的dom标签（html代码，参考官网代码）
> （4）创建swiper实例



**安装swiper**

`npm i swiper@5.4.5`



**在需要使用轮播图的组件内导入swpier和它的css样式**

home模块很多组件都使用到swiper.css,没必要在每一个组件内部都引入样式一次，只需要在入口文件引入一次即可。

**main.js**

```js
//引入swiper样式
import "swiper/css/swiper.css";
```

**在 ListContainer组件中引入 swiper**

```js
import Swiper from 'swiper'
```





**在组件中创建swiper需要的dom标签（html代码，参考官网代码）**

```html
<!--banner轮播-->
<div class="swiper-container" id="mySwiper">
    <div class="swiper-wrapper">
        <div class="swiper-slide" v-for="(carousel, index) in bannerList" :key="carousel.id">
            <img :src="carousel.imgUrl" />
        </div>
    </div>
    <!-- 如果需要分页器 -->
    <div class="swiper-pagination"></div>

    <!-- 如果需要导航按钮 -->
    <div class="swiper-button-prev"></div>
    <div class="swiper-button-next"></div>
</div>
```



**创建swiper实例**

初始化swiper实例之前，页面中的节点（结构）务必要有，对于Vue一个组件而言，mounted[组件挂载完毕：相应的结构不就有了吗]

mounted-->组件挂载完毕

但是会出现无法加载轮播图片的问题。

原因：

> 我们在mounted中先去异步请求了轮播图数据，然后又创建的swiper实例。由于请求数据是异步的，所以浏览器不会等待该请求执行完再去创建swiper，而是先创建了swiper实例，但是此时我们的轮播图数据还没有获得，就导致了轮播图展示失败。

```js
mounted() {
	//请求数据
    this.$store.dispatch("getBannerList")
    //创建swiper实例
    let mySwiper = new Swiper(document.getElementsByClassName("swiper-container"),{
        pagination:{
          el: '.swiper-pagination',
          clickable: true,
        },
        // 如果需要前进后退按钮
        navigation: {
          nextEl: '.swiper-button-next',
          prevEl: '.swiper-button-prev',
        },
        // 如果需要滚动条
        scrollbar: {
          el: '.swiper-scrollbar',
        },
      })
  },
```

解决方法一：等我们的数据请求完毕后再创建swiper实例。只需要加一个1000ms时间延迟再创建swiper实例.。将上面代码改为：

```js
mounted() {
    this.$store.dispatch("getBannerList")
    setTimeout(()=>{
      let mySwiper = new Swiper(document.getElementsByClassName("swiper-container"),{
        pagination:{
          el: '.swiper-pagination',
          clickable: true,
        },
        // 如果需要前进后退按钮
        navigation: {
          nextEl: '.swiper-button-next',
          prevEl: '.swiper-button-prev',
        },
        // 如果需要滚动条
        scrollbar: {
          el: '.swiper-scrollbar',
        },
      })
    },1000)
  },
```

方法一肯定不是最好的，但是我们开发的第一要义就是实现功能，之后再完善。

解决方法二：我们可以使用watch监听bannerList轮播图列表属性，因为bannerList初始值为空，当它有数据时，我们就可以创建swiper对象

```js
watch:{
    bannerList(newValue,oldValue){
        let mySwiper = new Swiper(this.$refs.cur,{
          pagination:{
            el: '.swiper-pagination',
            clickable: true,
          },
          // 如果需要前进后退按钮
          navigation: {
            nextEl: '.swiper-button-next',
            prevEl: '.swiper-button-prev',
          },
          // 如果需要滚动条
          scrollbar: {
            el: '.swiper-scrollbar',
          },
        })
    }
  }

```

即使这样也还是无法实现轮播图，原因是，我们轮播图的html中有v-for的循环，我们是通过v-for遍历bannerList中的图片数据，然后展示。我们的watch只能保证在bannerList变化时创建swiper对象，但是并不能保证此时v-for已经执行完了。假如watch先监听到bannerList数据变化，执行回调函数创建了swiper对象，之后v-for才执行，这样也是无法渲染轮播图图片（因为swiper对象生效的前提是html即dom结构已经渲染好了）。


**完美解决方案**：使用watch+[this.$nextTick()](https://cn.vuejs.org/v2/api/#vm-nextTick)

官方介绍：this. $nextTick它会将回调延迟到下次 DOM **更新循环之后执行**（循环就是这里的v-for）。

> 无非是等我们页面中的结构都有了再去执行回调函数
>
> this. $nextTick经常和很多插件配合使用，因为很多插件需要操作DOM

**完整代码**

```html
<template>
  <!--列表-->
  <div class="list-container">
    <div class="sortList clearfix">
      <div class="center">
        <!--banner轮播-->
        <div class="swiper-container" id="mySwiper">

          <div class="swiper-wrapper">
            <div class="swiper-slide" v-for="(carouse,index) in bannerList" :key="carouse.id">
              <img :src="carouse.imgUrl" />
            </div>
          </div>

          <!-- 如果需要分页器 -->
          <div class="swiper-pagination"></div>

          <!-- 如果需要导航按钮 -->
          <div class="swiper-button-prev" ></div>
          <div class="swiper-button-next"></div>
        </div>
      </div>
      </div>
    </div>
  </div>
</template>
<script>
//引入Swiper
import Swiper from 'swiper'
import {mapState} from "vuex";

export default {
  name: "index",
  //主键挂载完毕，ajax请求轮播图图片
  mounted() {
    this.$store.dispatch("getBannerList")
  },
  computed:{
    ...mapState({
    //从仓库中获取轮播图数据
      bannerList: (state) => {return state.home.bannerList}
    })
  },
  watch:{
    bannerList(newValue,oldValue){
        //this.$nextTick()使用
        this.$nextTick(()=>{
          let mySwiper = new Swiper(document.getElementsByClassName("swiper-container"),{
            pagination:{
              el: '.swiper-pagination',
              clickable: true,
            },
            // 如果需要前进后退按钮
            navigation: {
              nextEl: '.swiper-button-next',
              prevEl: '.swiper-button-prev',
            },
            // 如果需要滚动条
            scrollbar: {
              el: '.swiper-scrollbar',
            },
          })
        })
    }
  }
}
</script>

```

> 注意：之前我们在学习watch时，一般都是监听的定义在data中的属性，但是我们这里是监听的computed中的属性，这样也是完全可以的，并且如果你的业务数据也是从store中通过computed动态获取的，也需要watch监听数据变化执行相应回调函数，完全可以模仿上面的写法。





## 2.16 props父子组件通信

因为 home 组件有两个 floor，所以我们对 floor 组件进行 v-for 循环，并且把从 vuex 中取到的数据传给 floor组件渲染（父子组件可以通过 props 传数据）。

 **api/index.js**

> 写接口

```js
//获取floor数据
export const reqFloorList = () => moc   kRequests.get("/floor");
```



**存入 vuex**

```js
//home模块的小仓库
import { reqCategoryList, reqGetBannerList, reqFloorList } from '@/api';
//四大核心属性
//state：仓库数据的来源
const state = {
    //floor组件的数据
    floorList: []
};
//mutations:唯一可以改变state数据地方
const mutations = {
    GETFLOORLIST(state, floorList) {
        state.floorList = floorList;
    }
}
//actions:可以处理dispatch派发action地方，这里可以书写你的业务逻辑：for、if、异步语句等等
const actions = {
    //获取floor数据
    async getFloorList({ commit }) {
        let result = await reqFloorList();
        if (result.code == 200) {
            //提交mutation
            commit("GETFLOORLIST", result.data);
        }
    },
}
//getters：计算属性
const getters = {};
export default {
    state,
    mutations,
    actions,
    getters
}
```



**home.vue** 

```js
<template>
<div>
//...省略
<!--  父组件通过自定义属性list给子组件传递数据-->
  <Floor v-for="floor in floorList"  :key="floor.id" :list="floor"/>
<!--  商标-->
 
</div>
</template>


import { mapState } from "vuex";
export default {
  name: "Home",
  components: {
    ListContainer,
    Recommend,
    Rank,
    Like,
    Floor,
    Brand,
  },
  mounted() {
    //派发action,获取floor组件的数据
    this.$store.dispatch("getFloorList");
  },
  computed: {
    ...mapState({
      floorList: (state) => state.home.floorList,
    }),
  },
};
```



子组件：Floor下的index.vue

```html
<template>
  <!--楼层-->
  <div class="floor">
    //...省略
  </div>
</template>

<script>
export default {
  name: "floor",
  //子组件通过props属性接受父组件传递的数据
  props:['list'],
  //组件挂载完毕的地方
  mounted() {
    //第一次书写Swiper的时候：在mounted当中书写是不可以的，但是为什么现在这里可以啦！
    //第一次书写轮播图的时候，是在当前组件内部发请求、动态渲染解构【前台至少服务器数据需要回来】，因此当年的写法在这里不行
    //现在的这种写法为什么可以：因为请求是父组件发的，父组件通过props传递过来的，而且结构都已经有了的情况下执行mounted
    let mySwiper = new Swiper(
      document.getElementsByClassName("swiper-container"),
      {
        pagination: {
          el: ".swiper-pagination",
          clickable: true,
        },
        // 如果需要前进后退按钮
        navigation: {
          nextEl: ".swiper-button-next",
          prevEl: ".swiper-button-prev",
        },
        // 如果需要滚动条
        scrollbar: {
          el: ".swiper-scrollbar",
        },
      }
    );
  },
}
</script>

```



## 2.17 将轮播图模块提取为公共组件

需要注意的是我们要把定义swiper对象放在mounted中执行，并且还要设置immediate：true属性，这样可以实现，无论数据有没有变化，上来立即监听一次。



**公共组件Carousel代码**

```html
<template>
  <div class="swiper-container" ref="cur">
    <div class="swiper-wrapper">
      <div
        class="swiper-slide"
        v-for="(item, index) in list"
        :key="item.id"
      >
        <img :src="item.imgUrl" />
      </div>
    </div>
    <!-- 如果需要分页器 -->
    <div class="swiper-pagination"></div>

    <!-- 如果需要导航按钮 -->
    <div class="swiper-button-prev"></div>
    <div class="swiper-button-next"></div>
  </div>
</template>

<script>
//引入Swiper
import Swiper from "swiper";
export default {
  name: "Carousel",
  props: ["list"],
  watch: {
    list: {
      //立即监听：不管你数据有没有变化，我上来立即监听一次
      //为什么watch监听不大list：因为这个数据从来没有发生变化（数据是父亲给的，父亲给的时候就是一个对象，对象里面该有的数据都是有的）
      immediate: true,
      handler() {
        //只能监听到数据已经有了，但是v-for动态渲染结构我们还是没有办法确定的，因此还是需要用nextTick
        this.$nextTick(() => {
          new Swiper(this.$refs.cur, {
            loop: true,
            // 如果需要分页器
            pagination: {
              el: ".swiper-pagination",
              //点击小球的时候也切换图片
              clickable: true,
            },
            // 如果需要前进后退按钮
            navigation: {
              nextEl: ".swiper-button-next",
              prevEl: ".swiper-button-prev",
            },
          });
        });
      },
    },
  },
};
</script>

<style scoped></style>

```



Floor组件引用Carousel组件`<Carousel :carouselList="list.carouselList"/>`

ListContainer组件引用Carousel组件` <Carouse :carouselList="bannerList"/>`

> 解决一个 bug：
>
> 通过mock 假数据传来的图片地址，图片应该放在 public 文件夹下

## 2.18 Search路由

开发一个新组件的套路

* 书写静态页面【布局、样式】
* 拆分组件
* 获取服务器数据展示数据
* 写具体的业务



**搜索模块需要携带给接口的参数**

```json
{
  "category1Id": "61",//一级分类的id
  "category2Id": "61",//二级分类的id
  "category3Id": "61",//三级分类的id
  "categoryName": "手机",//产品的名字
  "keyword": "小米",//关键字
  "order": "1:desc",//排序
  "pageNo": 1,//当前第几页
  "pageSize": 10,//每一页需要展示多少条数据
  "props": ["1:1700-2799:价格", "2:6.65-6.74英寸:屏幕尺寸"],//平台属性的选择参数
  "trademark": "4:小米"//品牌参数
}
```



**拆分组件后的 search**

```html
<template>
  <div>
    <TypeNav></TypeNav>
    <div class="main">
      <div class="py-container">
        <!--bread-->
        <div class="bread">
          <ul class="fl sui-breadcrumb">
            <li>
              <a href="#">全部结果</a>
            </li>
          </ul>
          <ul class="fl sui-tag">
            <li class="with-x">手机</li>
            <li class="with-x">iphone<i>×</i></li>
            <li class="with-x">华为<i>×</i></li>
            <li class="with-x">OPPO<i>×</i></li>
          </ul>
        </div>

        <!--selector-->
        <SearchSelector />

        <!--details-->
        <div class="details clearfix">
          <div class="sui-navbar">
            <div class="navbar-inner filter">
              <ul class="sui-nav">
                <li class="active">
                  <a href="#">综合</a>
                </li>
                <li>
                  <a href="#">销量</a>
                </li>
                <li>
                  <a href="#">新品</a>
                </li>
                <li>
                  <a href="#">评价</a>
                </li>
                <li>
                  <a href="#">价格⬆</a>
                </li>
                <li>
                  <a href="#">价格⬇</a>
                </li>
              </ul>
            </div>
          </div>
          <div class="goods-list">
            <ul class="yui3-g">
              <li
                class="yui3-u-1-5"
                v-for="(good, index) in goodsList"
                :key="good.id"
              >
                <div class="list-wrap">
                  <div class="p-img">
                    <a href="item.html" target="_blank"
                      ><img :src="good.defaultImg"
                    /></a>
                  </div>
                  <div class="price">
                    <strong>
                      <em>¥ </em>
                      <i>{{ good.price }}</i>
                    </strong>
                  </div>
                  <div class="attr">
                    <a
                      target="_blank"
                      href="item.html"
                      title="促销信息，下单即赠送三个月CIBN视频会员卡！【小米电视新品4A 58 火爆预约中】"
                      >{{ good.title }}</a
                    >
                  </div>
                  <div class="commit">
                    <i class="command">已有<span>2000</span>人评价</i>
                  </div>
                  <div class="operate">
                    <a
                      href="success-cart.html"
                      target="_blank"
                      class="sui-btn btn-bordered btn-danger"
                      >加入购物车</a
                    >
                    <a href="javascript:void(0);" class="sui-btn btn-bordered"
                      >收藏</a
                    >
                  </div>
                </div>
              </li>
            </ul>
          </div>
          <div class="fr page">
            <div class="sui-pagination clearfix">
              <ul>
                <li class="prev disabled">
                  <a href="#">«上一页</a>
                </li>
                <li class="active">
                  <a href="#">1</a>
                </li>
                <li>
                  <a href="#">2</a>
                </li>
                <li>
                  <a href="#">3</a>
                </li>
                <li>
                  <a href="#">4</a>
                </li>
                <li>
                  <a href="#">5</a>
                </li>
                <li class="dotted"><span>...</span></li>
                <li class="next">
                  <a href="#">下一页»</a>
                </li>
              </ul>
              <div><span>共10页&nbsp;</span></div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

```



> 注意：搜索的接口，需要传递参数，至少是一个空对象（KV没有，但是至少给服务器一个对象）



**获取search模块数据**

```js
//获取搜索模块数据 地址:/api/list  请求方式:post  参数:需要带参数
//当前这个函数需不需要接受外部传递参数
//当前这个接口（获取搜索模块的数据），给服务器传递一个默认参数【至少是一个空对象】
export const reqGetSearchInfo = (params) => request({url:"/list",method:"post",data:params});
```



**vuex**

```js
import { reqGetSearchInfo } from "@/api";
//search模块的仓库
const state = {
    //仓库初始状态
    searchList: {}
};
const mutations = {
    GETSEARCHLIST(state, searchList) {
        state.searchList = searchList;
    },
};
const actions = {
    //获取search模块数据
    async getSearchList({ commit }, params = {}) {
        //当前这个reqGetSearchInfo这个函数在调用获取服务器数据的时候，至少传递一个参数（空对象）
        //params形参：是当用户派发action的时候，第二个参数传递过来的，至少是一个空对象
        let result = await reqGetSearchInfo(params);
        if (result.code == 200) {
            commit("GETSEARCHLIST", result.data);
        }
    },
};
//计算属性
//项目当中getters主要的作用是:简化仓库中的数据(简化数据而生)
//可以把我们将来在组件当中需要用的数据简化一下【将来组件在获取数据的时候就方便了】
const getters = {
    //当前形参state，当前仓库中的state，并非大仓库中的那个state
    goodsList(state) {
        //state.searchList.goodsList如果服务器数据回来了，没问题是一个数组
        //假如网络不给力|没有网state.searchList.goodsList应该返回的是undefined
        //计算新的属性的属性值至少给人家来一个数组
        return state.searchList.goodsList || [];
    }
    ,
    trademarkList(state) {
        return state.searchList.trademarkList || [];
    },
    attrsList(state) {
        return state.searchList.attrsList || [];
    }
};
export default {
    state,
    mutations,
    actions,
    getters,
};

```



**search 组件获取 vuex 数据**

```js
<script>
import SearchSelector from "./SearchSelector/SearchSelector";
import { mapGetters, mapState } from "vuex";
export default {
  name: "Search",

  components: {
    SearchSelector,
  },
  mounted() {
    // 先测试接口返回的数据
    this.$store.dispatch("getSearchList", {});
  },
  computed: {
    //mapGetters里面的写法：传递的数组，因为getters计算是没有划分模块【home,search】
    ...mapGetters(["goodsList"]),
  },
};
</script>
```



### 利用路由信息变化实现动态搜索

最初想法：在每个三级列表和收缩按钮加一个点击触发事件，只要点击了就执行搜索函数。

这是一个很蠢的想法，如果这样就会生成很多回调函数，很耗性能。

最佳方法：我们每次进行新的搜索时，我们的query和params参数中的部分内容肯定会改变，而且这两个参数是路由的属性。我们可以通过监听路由信息的变化来动态发起搜索请求。

如下图所示，$route是组件的属性，所以watch是可以监听的（watch可以监听组件data中所有的属性）

**注意**：组件中data的属性包括：自己定义的、系统自带的（如 $route）、父组件向子组件传递的等等。

> 把要发给服务器的数据先收集起来

```js
data() {
    //响应式数据
    return {
      //收集需要带给服务器参数，参数可变化的，响应式的
      //携带给服务器参数
      searchParams: {
        category1Id: "", //一级分类的id
        category2Id: "", //二级分类的id
        category3Id: "", //三级分类的id
        categoryName: "", //产品的名字
        keyword: "", //关键字
        props: [], //平台属性的选择参数
        trademark: "", //品牌参数
        //上面这七个参数：有用户选择决定的，因此初始值为空的
        //下面这三个：都有初始值
        order: "1:desc", //携带给服务器参数order--->初始值"1:desc"[综合降序]
        pageNo:1,
        // pageNo:parseInt(localStorage.getItem('pageNo'))||1, //获取第几页的数据，默认即为第一个的数据
        pageSize:3, //每一页需要展示多少条数据

      },
    };
  },
```

>在发请求之前，把携带给服务器参数整理好，携带服务器
>
>Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。
>
>1.如果目标对象中的属性具有相同的键，则属性将被源对象中的属性覆盖。后面的源对象的属性将类似地覆盖前面的源对象的属性
>
>2.Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象。该方法使用源对象的[[Get]]和目标对象的[[Set]]，所以它会调用相关 getter 和 setter。因此，它分配属性，而不仅仅是复制或定义新的属性。如果合并源包含getter，这可能使其不适合将新属性合并到原型中。为了将属性定义（包括其可枚举性）复制到原型，应使用Object.getOwnPropertyDescriptor()和Object.defineProperty() 。

```js
beforeMount() {
    //在发请求之前，把携带给服务器参数整理好，携带服务器
    //当路由跳转的时候，把home传递过来的query参数与params参数赋值给searchParams对象
    //Object.assign()合并对象
    Object.assign(this.searchParams, this.$route.query, this.$route.params);
},
```



**methods**

```js
methods: {
    //获取搜索产品的数据
    getSearchList() {
        //派发action通知服务器发请求
        //目前而言：组件通知服务器发请求，获取数据，携带一个空对象
        //当然将来这个空对象进行替换，替换我响应数据（收集用户选择调价带给服务器）
        //第二个参数：作为getSearchList这个action的第二个形参
        this.$store.dispatch("getSearchList", this.searchParams);
    }
}
```



**search组件watch部分代码。**

```js
//数据监听：监听组件实例身上的属性的属性值变化
watch: {
    //监听路由的信息是否发生变化，如果发生变化，再次发起请求
    $route(newValue, oldValue) {
        //每一次请求完毕，应该把相应的1、2、3级分类的id置空的，让他接受下一次的相应1、2、3
        //再次发请求之前整理带给服务器参数
        Object.assign(this.searchParams, this.$route.query, this.$route.params);
        //再次发起ajax请求
        this.getData();
        //分类名字与关键字不用清理：因为每一次路由发生变化的时候，都会给他赋予新的数据
        this.searchParams.category1Id = undefined;
        this.searchParams.category2Id = undefined;
        this.searchParams.category3Id = undefined;
    },
},
```



> 一些重复思想的代码就不赘述了
>
> search 子组件 SearchSelector 的数据渲染



## 2.19 面包屑相关操作

本次项目的面包屑操作主要就是两个删除逻辑。

分为：

当分类属性（query）删除时删除面包屑同时修改路由信息。

当搜索关键字（params）删除时删除面包屑、修改路由信息、同时删除输入框内的关键字。



**query删除时**

因为此部分在面包屑中是通过categoryName展示的，所所以删除时应将该属性值制空或undefined。可以通过路由再次跳转修改路由信息和url链接

```js
//删除分类的名字
removeCategoryName() {
    //把带给服务器的参数置空了，还需要向服务器发请求
    this.searchParams.categoryName = '';
    //地址栏也需要需改：进行路由跳转(现在的路由跳转只是跳转到自己这里)
    //严谨：本意是删除query，如果路径当中出现params不应该删除，路由跳转的时候应该带着
    if (this.$route.params) {
        this.$router.push({ name: "search", params: this.$route.params });
    }
},
```



**params删除时**

和query删除的唯一不同点是此部分会多一步操作：删除输入框内的关键字（因为params参数是从输入框内获取的），输入框实在Header组件中的。

header和search组件是兄弟组件，要实现该操作就要通过兄弟组件之间进行通信完成。

这里使用全局事件总线来完成。

（1）在main.js中注册

```js
new Vue({
  render: h => h(App),
  //全局事件总线$bus配置
  beforeCreate() {
    Vue.prototype.$bus = this;
  },
  router, // 注册路由器
  store
}).$mount('#app')
```



（2）search组件使用$bus通信

```js
//删除关键字
removeKeyword() {
    //给服务器带的参数searchParams的keyword置空
    this.searchParams.keyword = '';
    //通知兄弟组件Header清除关键字
    this.$bus.$emit("clear");
    //进行路由的跳转
    if (this.$route.query) {
        this.$router.push({ name: "search", query: this.$route.query });
    }
}
```

（3）header组件接受$bus通信

> 注意：组件挂载时就监听clear事件

```js
mounted() {
    //通过全局事件总线清除关键字
    this.$bus.$on("clear", () => {
        this.keyword = "";
    });
},
```



## 2.20 SearchSelector子组件传参(自定义事件）及面包屑操作

具体代码都在 search.vue 和 SearchSelector.vue 中

> 这里用到了一个知识点，子组件 SearchSelector 想给父组件 search 传数据，使用了自定义事件这个方法

**SearchSelector**

```html
<template>
  <div class="clearfix selector">
    <div class="type-wrap logo">
      <div class="fl key brand">品牌</div>
      <div class="value logos">
        <ul class="logo-list">
          <!-- 展示品牌的地方：遍历 -->
          <li
            v-for="(trademark, index) in trademarkList"
            :key="trademark.tmId"
            @click="tradeMatkHandler(trademark)"
          >
            {{ trademark.tmName }} 2
          </li>
        </ul>
      </div>
      <div class="ext">
        <a href="javascript:void(0);" class="sui-btn">多选</a>
        <a href="javascript:void(0);">更多</a>
      </div>
    </div>
    <div
      class="type-wrap"
      v-for="(attr, index) in attrsList"
      :key="attr.attrId"
    >
      <div class="fl key">{{ attr.attrName }}</div>
      <div class="fl value">
        <ul class="type-list">
          <!-- 平台相应售卖的属性的属性值:粉色，蓝色，黑色... -->
          <li v-for="(attrValue, index) in attr.attrValueList" :key="attrValue" @click="attrInfo(attr,attrValue)">
            <a>{{ attrValue }}</a>
          </li>
        </ul>
      </div>
      <div class="fl ext"></div>
    </div>
  </div>
</template>

<script>
//获取仓库中的数据
import { mapGetters } from "vuex";
export default {
  name: "SearchSelector",
  computed: {
    ...mapGetters(["trademarkList", "attrsList"]),
  },
  methods: {
    // 品牌的事件处理函数
    tradeMatkHandler(trademark) {
      //点击了品牌（苹果），还是需要整理参数，向服务器发请求获取相应的数据进行展示
      //老师问题：在哪个组件中发请求，父组件?
      //为什么那,因为父组件中searchParams参数是带给服务器参数，子组件组件把你点击的品牌的信息，需要给父组件传递过去---自定义事件
      this.$emit("trademarkInfo", trademark);
    },
    //平台售卖属性值的点击事件
    attrInfo(attr,attrValue){
      //["属性ID:属性值:属性名"]
      this.$emit("attrInfo",attr,attrValue);
    }
  },
};
</script>
```



**search**

```html
<template>
  <div>
    <TypeNav></TypeNav>
    <div class="main">
      <div class="py-container">
        <!--bread-->
        <div class="bread">
          <ul class="fl sui-breadcrumb">
            <li>
              <a href="#">全部结果</a>
            </li>
          </ul>
          <ul class="fl sui-tag">
            <!-- 分类的面包屑 -->
            <li class="with-x" v-if="searchParams.categoryName">
              {{ searchParams.categoryName }}
              <i @click="removeCategoryName">×</i>
            </li>
            <!-- 关键字的面包屑 -->
            <li class="with-x" v-if="searchParams.keyword">
              {{ searchParams.keyword }}<i @click="removeKeyword">×</i>
            </li>
            <!-- 品牌的面包屑 -->
            <li class="with-x" v-if="searchParams.trademark">
              {{ searchParams.trademark.split(":")[1]
              }}<i @click="removeTradeMark">×</i>
            </li>
            <!--平台的售卖的属性值展示 -->
            <li
              class="with-x"
              v-for="(attrValue, index) in searchParams.props"
              :key="index"
            >
              {{ attrValue.split(":")[1] }}<i @click="removeAttr(index)">×</i>
            </li>
          </ul>
        </div>

        <!--selector-->
        <SearchSelector @trademarkInfo="trademarkInfo" @attrInfo="attrInfo"/>

        <!--details-->
        <div class="details clearfix">
          <div class="sui-navbar">
            <div class="navbar-inner filter">
              <ul class="sui-nav">
                <li class="active">
                  <a href="#">综合</a>
                </li>
                <li>
                  <a href="#">销量</a>
                </li>
                <li>
                  <a href="#">新品</a>
                </li>
                <li>
                  <a href="#">评价</a>
                </li>
                <li>
                  <a href="#">价格⬆</a>
                </li>
                <li>
                  <a href="#">价格⬇</a>
                </li>
              </ul>
            </div>
          </div>
          <div class="goods-list">
            <ul class="yui3-g">
              <li
                class="yui3-u-1-5"
                v-for="(good, index) in goodsList"
                :key="good.id"
              >
                <div class="list-wrap">
                  <div class="p-img">
                    <a href="item.html" target="_blank"
                      ><img :src="good.defaultImg"
                    /></a>
                  </div>
                  <div class="price">
                    <strong>
                      <em>¥ </em>
                      <i>{{ good.price }}</i>
                    </strong>
                  </div>
                  <div class="attr">
                    <a
                      target="_blank"
                      href="item.html"
                      title="促销信息，下单即赠送三个月CIBN视频会员卡！【小米电视新品4A 58 火爆预约中】"
                      >{{ good.title }}</a
                    >
                  </div>
                  <div class="commit">
                    <i class="command">已有<span>2000</span>人评价</i>
                  </div>
                  <div class="operate">
                    <a
                      href="success-cart.html"
                      target="_blank"
                      class="sui-btn btn-bordered btn-danger"
                      >加入购物车</a
                    >
                    <a href="javascript:void(0);" class="sui-btn btn-bordered"
                      >收藏</a
                    >
                  </div>
                </div>
              </li>
            </ul>
          </div>
          <div class="fr page">
            <div class="sui-pagination clearfix">
              <ul>
                <li class="prev disabled">
                  <a href="#">«上一页</a>
                </li>
                <li class="active">
                  <a href="#">1</a>
                </li>
                <li>
                  <a href="#">2</a>
                </li>
                <li>
                  <a href="#">3</a>
                </li>
                <li>
                  <a href="#">4</a>
                </li>
                <li>
                  <a href="#">5</a>
                </li>
                <li class="dotted"><span>...</span></li>
                <li class="next">
                  <a href="#">下一页»</a>
                </li>
              </ul>
              <div><span>共10页&nbsp;</span></div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
import SearchSelector from "./SearchSelector/SearchSelector";
import { mapGetters, mapState } from "vuex";
export default {
  name: "Search",
  data() {
    return {
      //收集需要带给服务器参数，参数可变化的，响应式的
      //携带给服务器参数
      searchParams: {
        category1Id: "", //一级分类的id
        category2Id: "", //二级分类的id
        category3Id: "", //三级分类的id
        categoryName: "", //产品的名字
        keyword: "", //关键字
        props: [], //平台属性的选择参数
        trademark: "", //品牌参数
        //上面这七个参数：有用户选择决定的，因此初始值为空的
        //下面这三个：都有初始值
        order: "1:desc", //携带给服务器参数order--->初始值"1:desc"[综合降序]
        pageNo: 1,
        // pageNo:parseInt(localStorage.getItem('pageNo'))||1, //获取第几页的数据，默认即为第一个的数据
        pageSize: 5, //每一页需要展示多少条数据
      },
    };
  },
  components: {
    SearchSelector,
  },
  //生命周期函数
  beforeMount() {
    //在发请求之前，把携带给服务器参数整理好，携带服务器
    //当路由跳转的时候，把home传递过来的query参数与params参数赋值给searchParams对象
    //Object.assign()合并对象
    Object.assign(this.searchParams, this.$route.query, this.$route.params);
  },
  //组件挂载完毕发起一次请求
  mounted() {
    //在发请求之前咱们需要将searchParams里面参数进行修改带给服务器
    this.getData();
  },
  computed: {
    //mapGetters里面的写法：传递的数组，因为getters计算是没有划分模块【home,search】
    ...mapGetters(["goodsList"]),
  },
  methods: {
    //获取搜索产品的数据
    getData() {
      //派发action通知服务器发请求
      //目前而言：组件通知服务器发请求，获取数据，携带一个空对象
      //当然将来这个空对象进行替换，替换我响应数据（收集用户选择调价带给服务器）
      //第二个参数：作为getSearchList这个action的第二个形参
      this.$store.dispatch("getSearchList", this.searchParams);
    },
    //删除分类的名字
    removeCategoryName() {
      //把带给服务器的参数置空了，还需要向服务器发请求
      this.searchParams.categoryName = '';
      //地址栏也需要需改：进行路由跳转(现在的路由跳转只是跳转到自己这里)
      //严谨：本意是删除query，如果路径当中出现params不应该删除，路由跳转的时候应该带着
      if (this.$route.params) {
        this.$router.push({ name: "search", params: this.$route.params });
      }
    },
    //删除关键字
    removeKeyword() {
      //给服务器带的参数searchParams的keyword置空
      this.searchParams.keyword = '';
      //通知兄弟组件Header清除关键字
      this.$bus.$emit("clear");
      //进行路由的跳转
      if (this.$route.query) {
        this.$router.push({ name: "search", query: this.$route.query });
      }
    },
    // SearchSelector子组件自定义事件回调
    trademarkInfo(trademark) {
      //1:整理品牌字段的参数  "ID:品牌名称"
      this.searchParams.trademark = `${trademark.tmId}:${trademark.tmName}`;
      //再次发请求获取search模块列表数据进行展示
      this.getData();
    },
    // 收集平台属性地方回调函数（自定义事件）
    attrInfo(attr, attrValue) {
      console.log(attr, attrValue);
      //参数格式整理好
      let props = `${attr.attrId}:${attrValue}:${attr.attrName}`;
      //数组去重
      if (this.searchParams.props.indexOf(props) == -1)
        this.searchParams.props.push(props);
      //再次发请求
      this.getData();
    },
    //删除品牌的信息
    removeTradeMark() {
      //将品牌信息置空
      this.searchParams.trademark = '';
      //再次发请求
      this.getData();
    },
    //removeAttr删除售卖的属性
    removeAttr(index) {
      //再次整理参数
      this.searchParams.props.splice(index, 1);
      //再次发请求
      this.getData();
    }
  },
  //数据监听：监听组件实例身上的属性的属性值变化
  watch: {
    //监听路由的信息是否发生变化，如果发生变化，再次发起请求
    $route(newValue, oldValue) {
      //每一次请求完毕，应该把相应的1、2、3级分类的id置空的，让他接受下一次的相应1、2、3
      //再次发请求之前整理带给服务器参数
      Object.assign(this.searchParams, this.$route.query, this.$route.params);
      //再次发起ajax请求
      this.getData();
      //分类名字与关键字不用清理：因为每一次路由发生变化的时候，都会给他赋予新的数据
      this.searchParams.category1Id = undefined;
      this.searchParams.category2Id = undefined;
      this.searchParams.category3Id = undefined;
    },
  },
};
</script>
```

> 请求的性能优化:
>
> 发一个请求，需要向服务器携带参数：带100个参数  带1参数  【消耗宽带】
>
> 对于给服务器携带的参数：如果数值为undefind，向服务器发请求的时候，参数步携带给服务器的



## 2.21 商品排序

排序的逻辑比较简单，只是改变一下请求参数中的order字段，后端会根据order值返回不同的数据来实现升降序。

order属性值为字符串，例如'1：asc'、'2：desc'。1代表综合，2代表价格，asc代表升序，desc代表降序。

图标是iconfont网站的图标，通过引入在线css的方式引入图标

**在search模块使用该图标**

```html
<ul class="sui-nav">
    <li :class="{ active: isOne }" @click="changeOrder('1')">
        <a
           >综合<span
                    v-show="isOne"
                    class="iconfont"
                    :class="{ 'icon-up': isAsc, 'icon-down': isDesc }"
                    ></span
            ></a>
    </li>
    <li :class="{ active: isTwo }" @click="changeOrder('2')">
        <a
           >价格<span
                    v-show="isTwo"
                    class="iconfont"
                    :class="{ 'icon-up': isAsc, 'icon-down': isDesc }"
                    ></span
            ></a>
    </li>
</ul>
```

**isOne、isTwo、isAsc、isDesc计算属性代码**

```js
computed: {
    //mapGetters里面的写法：传递的数组，因为getters计算是没有划分模块【home,search】
    ...mapGetters(["goodsList"]),
    isOne() {
      return this.searchParams.order.indexOf("1") != -1;
    },
    isTwo() {
      return this.searchParams.order.indexOf("2") != -1;
    },
    isAsc() {
      return this.searchParams.order.indexOf("asc") != -1;
    },
    isDesc() {
      return this.searchParams.order.indexOf("desc") != -1;
    },
 },
```



点击综合或价格的触发排序函数changeOrder

```js
//排序的操作
changeOrder(flag) {
    //flag:用户每一次点击li标签的时候，用于区分是综合（1）还是价格（2）
    //现获取order初始状态【咱们需要通过初始状态去判断接下来做什么】
    let originOrder = this.searchParams.order;
    let originFlag = originOrder.split(":")[0];
    let originSort = originOrder.split(":")[1];
    //新的排序方式
    let newOrder = "";
    //判断的是多次点击的是不是同一个按钮
    if(flag == originFlag) {
        newOrder = `${flag}:${originSort == 'desc'?'asc':'desc'}`
    } else {
        //点击不是同一个按钮
        newOrder = `${flag}:${"desc"}`;
    }
    //需要给order重新赋值
    this.searchParams.order = newOrder;
    // 再次发请求
    this.getData();
}
```



## 2.22 手写分页器

前端三大件:轮播图、分页、日历。这属于前端开发常见三种业务

为什么很多项目中都采用分页功能?

比如电商平台：搜索一个奶粉，奶粉的产品有10000+，一次渲染10000+条数据，可能慢。

数据多的时候，可以选择分页，比如每一次只是展示10。

**分页器封装业务分析:**

1:分页器组件需要知道我一共展示多少条数据 ----total【100条数据】

2:每一个需要展示几条数据------pageSize【每一页3条数据】

3:需要知道当前在第几页-------pageNo【当前在第几页】

4:需要知道连续页码数【起始数字、结束数字：连续页码数市场当中一般5、7、9】奇数，对称好看 continues

**pagination组件：**

```html
<template>
  <div class="pagination">
    <!-- 上 -->
    <button :disabled="pageNo == 1" @click="$emit('getPageNo', pageNo - 1)">
      上一页
    </button>
    <button
      v-if="startNumAndEndNum.start > 1"
      @click="$emit('getPageNo', 1)"
      :class="{ active: pageNo == 1 }"
    >
      1
    </button>
    <button v-if="startNumAndEndNum.start > 2">···</button>
    <!-- 中间部分 -->
    <button
      v-for="(page, index) in startNumAndEndNum.end"
      :key="index"
      v-if="page >= startNumAndEndNum.start"
      @click="$emit('getPageNo', page)"
      :class="{ active: pageNo == page }"
    >
      {{ page }}
    </button>

    <!-- 下 -->
    <button v-if="startNumAndEndNum.end < totalPage - 1">···</button>
    <button
      v-if="startNumAndEndNum.end < totalPage"
      @click="$emit('getPageNo', totalPage)"
      :class="{active:pageNo==totalPage}"
    >
      {{ totalPage }}
    </button>
    <button
      :disabled="pageNo == totalPage"
      @click="$emit('getPageNo', pageNo + 1)"
    >
      下一页
    </button>

    <button style="margin-left: 30px">共 {{ total }} 条</button>
  </div>
</template>

<script>
export default {
  name: "Pagination",
  props: ["pageNo", "pageSize", "total", "continues"],
  computed: {
    //总共多少页
    totalPage() {
      //向上取证
      return Math.ceil(this.total / this.pageSize);
    },
    //计算出连续的页码的起始数字与结束数字[连续页码的数字:至少是5]
    startNumAndEndNum() {
      const { continues, pageNo, totalPage } = this;
      //先定义两个变量存储起始数字与结束数字
      let start = 0,
        end = 0;
      //连续页码数字5【就是至少五页】，如果出现不正常的现象【就是不够五页】
      //不正常现象【总页数没有连续页码多】
      if (continues > totalPage) {
        start = 1;
        end = totalPage;
      } else {
        //正常现象【连续页码5，但是你的总页数一定是大于5的】
        //起始数字
        start = pageNo - parseInt(continues / 2);
        //结束数字
        end = pageNo + parseInt(continues / 2);
        //把出现不正常的现象【start数字出现0|负数】纠正
        if (start < 1) {
          start = 1;
          end = continues;
        }
        //把出现不正常的现象[end数字大于总页码]纠正
        if (end > totalPage) {
          end = totalPage;
          start = totalPage - continues + 1;
        }
      }
      return { start, end };
    },
  },
};
</script>

<style lang="less" scoped>
.pagination {
  text-align: center;
  button {
    margin: 0 5px;
    background-color: #f4f4f5;
    color: #606266;
    outline: none;
    border-radius: 2px;
    padding: 0 4px;
    vertical-align: top;
    display: inline-block;
    font-size: 13px;
    min-width: 35.5px;
    height: 28px;
    line-height: 28px;
    cursor: pointer;
    box-sizing: border-box;
    text-align: center;
    border: 0;

    &[disabled] {
      color: #c0c4cc;
      cursor: not-allowed;
    }

    &.active {
      cursor: not-allowed;
      background-color: #409eff;
      color: #fff;
    }
  }
}
.active{
  background: skyblue;
}
</style>

```

> 当点击页码会将pageNo传递给父组件，然后父组件发起请求，最后渲染。这里还是应用通过自定义事件实现子组件向父组件传递信息。



**滚动条**

使用前端路由，当切换到新路由时，想要页面滚到顶部，或者是保持原先的滚动位置，就像重新加载页面那样。 vue-router 能做到，而且更好，它让你可以自定义路由切换时页面如何滚动。

滚动条参考：https://router.vuejs.org/zh/guide/advanced/scroll-behavior.html





## 2.23 detail组件

商品详情难点就是点击轮播图图片时，改变放大镜组件展示的图片。

方法：在轮播图组件中设置一个currendIndex，用来记录所点击图片的下标，并用currendIndex实现点击图片高亮设置。当符合图片的下标满足`currentIndex===index`时，该图片就会被标记为选中。

```html
<div class="swiper-container" ref="cur">
    <div class="swiper-wrapper">
        <div class="swiper-slide" v-for="(skuImage,index) in skuImageList" :key="skuImage.id">
            <img :src="skuImage.imgUrl" :class="{active:currentIndex===index}" @click="changeImg(index)">
        </div>
    </div>
    <div class="swiper-button-next"></div>
    <div class="swiper-button-prev"></div>
</div>
```

轮播图组件和放大镜组件是兄弟组件，所以要通过全局总线通信。

在轮播图组件中，点击图片触发全局事件changeImg，参数为图片所在数组的下标。

```js
changeImg(index){
    //将点击的图片标识位高亮
    this.currentIndex = index
    //通知兄弟组件修改大图图片
    this.$bus.$emit("changeImg",index)
}
```

对应的放大镜组件，首先在mounted监听该全局事件

```js
mounted() {
    this.$bus.$on("changeImg",(index)=>{
        //修改当前响应式图片
        this.currentIndex = index;
    })
},
```

放大镜组件中也会有一个currentIndex，他用表示大图中显示的图片的下标（因为放大镜组件只能显示一张图片），全局事件传递的index赋值给currentIndex ，通过computed计算属性改变放大镜组件展示的图片下标。

```js
computed:{
    imgObj(){
        return this.skuImageList[this.currentIndex] || {}
    }
},
```

> 放大镜的详细css知识可以去看尚硅谷的js





## 2.24 undefined细节

访问undefined的属性值会引起红色警告，可以不处理，但是要明白警告的原因。
以获取商品categoryView信息为例，categoryView是一个对象。
对应的getters代码

```js
const getters =  {
    categoryView(state){
        return state.goodInfo.categoryView
    }
}
```

对应的computed代码

```js
computed:{
    ...mapGetters(['categoryView'])
}
```

html代码

```html
<div class="conPoin">
    <span v-show="categoryView.category1Name" >{{categoryView.category1Name}}</span>
    <span v-show="categoryView.category2Name" >{{categoryView.category2Name}}</span>
    <span v-show="categoryView.category3Name" >{{categoryView.category3Name}}</span>
</div>
```

下细节在于getters的返回值。如果getters按上面代码写为`return state.goodInfo.categoryView`，页面可以正常运行，但是会出现红色警告。

![在这里插入图片描述](https://img-blog.csdnimg.cn/ce4126524cc046f69a84f85a10ebda9b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5q-b5q-b6Jmr5ZGc5ZGc,size_20,color_FFFFFF,t_70,g_se,x_16)

**原因**：假设我们网络故障，导致goodInfo的数据没有请求到，即goodInfo是一个空的对象，当我们去调用getters中的return state.goodInfo.categoryView时，因为goodInfo为空，所以也不存在categoryView，即我们getters得到的categoryView为undefined。所以我们在html使用该变量时就会出现没有该属性的报错。
即：网络正常时不会出错，一旦无网络或者网络问题就会报错。



**总结**：所以我们在写getters的时候要养成一个习惯在返回值后面加一个||条件。即当属性值undefined时，会返回||后面的数据，这样就不会报错。
如果返回值为对象加||{}，数组：||[ ]。
此处categoryView为对象，所以将getters代码改为return state.goodInfo.categoryView||{}



## 2.25 失焦事件

blur与change事件在绝大部分情况下表现都非常相似，输入结束后，离开输入框，会先后触发change与blur，唯有两点例外。

（1） 没有进行任何输入时，不会触发change。
在这种情况下，输入框并不会触发change事件，但一定会触发blur事件。在判断表单修改状态时，这种差异会非常有用，通过change事件能轻易地找到哪些字段发生了变更以及其值的变更轨迹。



（2）输入后值并没有发生变更。
这种情况是指，在没有失焦的情况下，在输入框内进行返回的删除与输入操作，但最终的值与原值一样，这种情况下，keydown、input、keyup、blur都会触发，但change依旧不会触发。



## 2.26 加入购物车成功路由

点击加入购物车时，会向后端发送API请求，但是该请求的返回值中data为null，所以我们只需要根据状态码code判断是否跳转到‘加入购物车成功页面’。
detail组件‘加入购物车’请求函数：

```js
//加入购物车
addShopCar() {
    //1:在点击加入购物车这个按钮的时候，做的第一件事情，将参数带给服务器（发请求），通知服务器加入购车的产品是谁
    //this.$store.dispatch('addOrUpdateShopCart'),说白了，它是在调用vuex仓库中的这个addOrUpdateShopCart函数。
    //2:你需要知道这次请求成功还是失败，如果成功进行路由跳转，如果失败，需要给用户提示
    try {
        // 成功
        this.$store.dispatch("addOrUpdateShopCart", {
            skuId: this.$route.params.skuId,
            skuNum: this.skuNum,
        });
        //3:进行路由跳转
        //4:在路由跳转的时候还需要将产品的信息带给下一级的路由组件
        //一些简单的数据skuNum，通过query形式给路由组件传递过去
        //产品信息的数据【比较复杂:skuInfo】,通过会话存储（不持久化,会话结束数据在消失）
        //本地存储|会话存储，一般存储的是字符串
        sessionStorage.setItem("SKUINFO", JSON.stringify(this.skuInfo));
        this.$router.push({name: 'addcartsuccess', query: {skuNum: this.skuNum}});
    } catch (error) {
        //失败
        alert(error.message);
    }
}
```

detail store对应代码

```js
//加入购物车的||修改某一个产品的个数
async addOrUpdateShopCart({ commit }, { skuId, skuNum }) {
    //发请求:前端带一些参数给服务器【需要存储这些数据】，存储成功了，没有给返回数据
    //不需要在三连环（仓库存储数据了）
    //注意:async函数执行返回的结果一定是一个promise【要么成功，要么失败】
    let result = await reqAddOrUpdateShopCart(skuId, skuNum)
    if(result.code == 200) {
        //返回的是成功的标记
        return "ok";
    } else {
        //返回的是失败的标记
        return Promise.reject(new Error("false"));
    }
}
```

其实这里当不满足result.code === 200条件时，也可以返回字符串‘false’，自己在addShopCar中判断一下返回值，如果为‘ok’则跳转，如果为‘faile’(或者不为‘ok’)直接提示错误。当然这里出错时返回一个Promise.reject更加符合程序的逻辑。




当我们想要实现**两个毫无关系**的组件传递数据时，首先想到的就是路由的query传递参数，但是query适合传递单个数值的简单参数，所以如果想要**传递对象**之类的复杂信息，就可以通过**Web Storage**实现。

> **sessionStorage、localStorage** 在前面 vue基础讲过，就不提了



## 2.27 购物车组件开发

根据api接口文档封装请求函数

```js
//获取购物车列表数据接口
//URL:/api/cart/cartList   method:get 
export const reqCartList = () => request({url:'/cart/cartList ',method:'get'});
```

但是如果想要获取详细信息，还需要一个用户的uuidToken，用来验证用户身份。但是该请求函数没有参数，所以我们只能把uuidToken加在请求头中。

创建utils工具包文件夹，创建生成uuid的js文件，对外暴露为函数

**生成临时游客的uuid（随机字符串）,每个用户的uuid不能发生变化，还要持久存储**

```js
import {v4 as uuidv4} from 'uuid'
//生成临时游客的uuid（随机字符串）,每个用户的uuid不能发生变化，还要持久存储
export const getUUID = () => {
    //1、判断本地存储是否由uuid
    let uuid_token = localStorage.getItem('UUIDTOKEN')
    //2、本地存储没有uuid
    if(!uuid_token){
        //2.1生成uuid
        uuid_token = uuidv4()
        //2.2存储本地
        localStorage.setItem("UUIDTOKEN",uuid_token)
    }
    //当用户有uuid时就不会再生成
    return uuid_token
}
```

用户的uuid_token定义在store中的detail模块

```js
const state =  {
    goodInfo:{},
    //游客身份
    uuid_token: getUUID()
}
```

在request.js中设置请求头

```js
import store from '@/store';
requests.interceptors.request.use(config => {
    //config内主要是对请求头Header配置

    //1、先判断uuid_token是否为空
    if(store.state.detail.uuid_token){
        //2、userTempId字段和后端统一
        config.headers['userTempId'] = store.state.detail.uuid_token
    }
    //比如添加token

    //开启进度条
    nprogress.start();
    return config;
})
```

> 注意this.$store只能在组件中使用，不能再js文件中使用。如果要在js中使用，需要引入`import store from '@/store';`



## 2.28 购物车商品数量修改及个人疑问

1、购物车商品信息展示比较简单，就不多做赘述。
2、every函数使用

> every遍历某个数组，判断数组中的元素是否满足表达式，全部为满足返回true，否则返回false

例如判断底部勾选框是否全部勾选代码部分

```js
//判断底部勾选框是否全部勾选
isAllCheck() {
    //every遍历某个数组，判断数组中的元素是否满足表达式，全部为满足返回true，否则返回false
    return this.cartInfoList.every(item => item.isChecked === 1)
}
```

3、修改商品数量前端代码部分：
**注意**：通过@click、@change触发handler函数改变商品数量。
**引申**：在我自己写代码的同时，我发现，当使用函数的参数个数不同时，例如：handler(‘minus’,-1,cartInfo)和 handler(‘minus’,-1)，执行的还是同一个method的handler函数，只是对应的参数变为了undefined。即js不会像java一样，有代码的重载。

```html
 <li class="cart-list-con5">
     <a href="javascript:void(0)" class="mins" @click="handler('minus',-1,cartInfo)">-</a>
     <input autocomplete="off" type="text" :value="cartInfo.skuNum" @change="handler('change',$event.target.value,cartInfo)" minnum="1" class="itxt">
     <a href="javascript:void(0)" class="plus" @click="handler('add',1,cartInfo)">+</a>
 </li>
```

handler函数，修改商品数量时，加入节流操作。

> 添加到购物车和对已有物品进行数量改动使用的同一个api，可以查看api文档。
> handler函数有三个参数，type区分操作，disNum用于表示数量变化（正负）,cart商品的信息

```js
//加入节流操作
handler: throttle(async  function(type,disNum,cart){
    //减按钮判断当前数量是否为1
    if(type === 'minus') {
        //当商品数量为1是，不可以再减少
        if(cart.skuNum === 1){
            return;
        }
    }
    //输入框修改,难点：要判断输入的内容是否合法
    if(type === 'change'){
        //输入内容不合法时
        if(isNaN(disNum * 1)  || disNum <= 0){
            disNum = 0;
        }else{
            disNum = parseInt(disNum) - cart.skuNum
        }
    }
    //加按钮disNum不需要改变
    try{
        await this.$store.dispatch('addOrUpdateShopCart',{skuId:cart.skuId,skuNum:disNum})
        //商品数量修改成功后再次获取服务器数据
        await this.$store.dispatch("getCartList")

    }catch (error){
        alert(error)
    }
},100),
```

**个人疑点**：在最后一步更新商品信息时，我最初的想法时使用this.$router.push('/shopcart')实现。因为，我们shopcart页面的mounted会去获取商品信息。当路由跳转时会执行mounted的内容，实现商品数据信息更新。

```js
mounted(){
    this.$store.dispatch("getCartList")
},
```

但是这样做不会更新商品数据，个人猜测原因是：因为我要跳往的路由和当前路由相同，并且路由参数没有改变，所以他就不会跳转。或者是会跳转。但是，因为路由信息没有变化，所以不会执行mounted函数。
这里还是自己对路由和mounted内容不够了解，有了解的小伙伴可以帮我解答一下疑问吗？欢迎评论区解答。





## 2.29 购物车状态修改和商品删除

这部分都比较简单，这里不多做赘述，唯一需要注意的是当store的action中的函数返回值data为null时，应该采用下面的写法（**重点是if，else部分**）

action部分：以删除购物车某个商品数据为例

```js
//修改购物车某一个产品的选中状态
async reqUpdateCheckedById({commit},{skuId,isChecked}){
    let result = await reqUpdateCheckedById(skuId,isChecked)
    if(result.code === 200){
        return 'ok'
    }else{
        return Promise.reject(new Error('fail'))
    }
}
```

method部分：（**重点是try、catch**）

```js
async reqUpdateCheckedById(cart,event){
    let isChecked = event.target.checked ? 1 :0
    try{
        await this.$store.dispatch("reqUpdateCheckedById",{skuId:cart.skuId,isChecked:isChecked})
        //修改成功，刷新数据
        this.$store.dispatch()
    }catch (error){
        this.$store.dispatch("getCartList")
    }
}
```



## 2.30 删除多个商品（actions扩展）

由于后台只提供了删除单个商品的接口，所以要删除多个商品时，只能多次调用actions中的函数。

我们可能最简单的方法是在method的方法中多次执行dispatch删除函数，当然这种做法也可行，但是为了深入了解actions，我们还是要将批量删除封装为actions函数。

actions扩展
官网的教程，一个标准的actions函数如下所示：

```js
deleteAllCheckedById(context) {
    console.log(context)
}
```

我们可以看一下context到底是什么。

![在这里插入图片描述](https://img-blog.csdnimg.cn/f2767f2ab7df4046b71e675d979ca3ec.png)



context中是包含dispatch、getters、state的，即我们可以在actions函数中通过dispatch调用其他的actions函数，可以通过getters获取仓库的数据。

这样我们的批量删除就简单了，对应的actions函数代码让如下

```js
/删除选中的所有商品
deleteAllCheckedById({dispatch,getters}) {
    getters.getCartList.cartInfoList.forEach(item =>  {
        let result = [];
        //将每一次返回值添加到数组中
        result.push(item.isChecked === 1?dispatch('deleteCartById',item.skuId):'')


    })
    return Promise.all(result)
},

```

上面代码使用到了Promise.all

> Promise.all可以将多个Promise实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值。



购物车组件method批量删除函数

```js
//删除选中的所有商品
async deleteAllCheckedById(){
    try{
        await this.$store.dispatch('deleteAllCheckedById')
        //删除成功，刷新数据
        this.$store.dispatch("getCartList")
    }catch (error){
        alert(error)
    }
},

```

修改商品的全部状态和批量删除的原理相同，直接贴代码。
actions

```js
//修改购物车全部产品的选中状态
async updateAllChecked({dispatch,getters},flag){
    let result = []
    getters.getCartList.cartInfoList.forEach(item => {
        result.push(dispatch('reqUpdateCheckedById',{skuId:item.skuId,isChecked:flag
                                                    }))
    })
    return Promise.all(result)
}
```

method

```js
//修改全部商品的状态
async allChecked(event){
    let flag =  event.target.checked ? 1 : 0
    console.log(flag)
    try{
        await this.$store.dispatch('updateAllChecked',flag)
        //修改成功，刷新数据
        this.$store.dispatch("getCartList")
    }catch (error){
        alert(error)
    }
}
```

**bug纠正**
computed中的cartInfoList没有写[ ]返回值。当后台返回的购物车数据为空时，cartInfoList 就会为undefined，会导致后面的total、isAllCheck等计算属性使用到cartInfoList时产生计算错误。

正确代码:

```js
cartInfoList(){
    return this.getCartList.cartInfoList || [];
},
```

错误代码:

```js
cartInfoList(){
    return this.getCartList.cartInfoList;
},
```



## 2.31 注册登录业务

对于企业当中，一般项目都有登录注册功能【这个业务很重要】。当然有一些项目不需要注册，后台管理系统项目，一般不需要注册。

> assets【放置静态资源文件的地方】
>
> 一般放置所有组件共用的静态资源
>
> 在样式当中也可以使用@,在样式当中使用@，前面加上~



### **用户注册模块**

```js
//用户注册
async userRegister({commit},data){
    let result = await reqPostRegister(data)
    if(result.code === 200){
        return 'ok'
    }else{
        return Promise.reject(new Error(result.message))
    }
}

```

methods注册功能

注册成功跳转到登陆页面，并且携带用户账号（个人完善）

```js
async userRegister(){
    const{phone,password,code} = this
    try{
        phone && password && code && await this.$store.dispatch('userRegister',{phone,password,code})
        //注册成功跳转到登陆页面，并且携带用户账号
        this.$router.push({path:'/login',query:{name:this.phone}})
    }catch (error){
        alert(error)
    }
},

```



### **登录模块**

前端部分内容

```html
<form >
    <div class="input-text clearFix">
        <span></span>
        <input type="text" placeholder="邮箱/用户名/手机号" v-model="phone">
    </div>
    <div class="input-text clearFix">
        <span class="pwd"></span>
        <input type="password" placeholder="请输入密码" v-model="password">
    </div>
    <div class="setting clearFix">
        <label class="checkbox inline">
            <input name="m1" type="checkbox" value="2" checked="">
            自动登录
        </label>
        <span class="forget">忘记密码？</span>
    </div>
    <button class="btn" @click.prevent="goLogin">登&nbsp;&nbsp;录</button>
</form>
```

由于登录按钮的父节点是一个form表单，如果使用@click触发登录事件，form表单会执行默认事件action实现页面跳转。这里我们使用`@click.prevent`，它可以阻止自身默认事件的执行。

actions登陆函数

```js
//登录
async userLogin({commit},data){
    let result = await reqPostLogin(data)
    //服务器会返回token
    if(result.code === 200){
        //token存入vuex
        commit("SETUSERTOKEN",result.data.token)
        //持久化存储token
        localStorage.setItem('TOKEN',result.data.token)
        return 'ok'
    }else{
        return Promise.reject(new Error(result.message))
    }
},

```

mutations设置用户token

```js
//设置用户token
USERLOGIN(state,token){
    state.token = token
}
```

登陆组件methods登陆函数

```js
async goLogin(){
    try{
        //会将this中的phone,password以对象的形式返回
        const {phone,password} = this
        phone && password && await this.$store.dispatch('userLogin',{phone,password})
        //路由跳转到home首页
        this.$router.push('/home')
    }catch (error){
        alert(error)
    }
}

```

登陆成功后获取用户信息

actions函数

```js
async getUserInfo({commit}){
    let result = await reqGetUserInfo();
    //将用户信息存储到store中
    if(result.code === 200){
        //vuex存储用户信息
        commit('GETUSERINFO',result.data)
        return  'ok'
    }else{
        return Promise.reject(new Error(result.message))
    }
},
```



为什么去别的模块【非home模块】获取用户信息失败？

因为你去别的模块根本没有发请求获取用户信息，没办法展示用户信了



怎么解决:

每一个组件都在mounted里面发起获取用户信息，进行展示（可以太麻烦）

残留的问题：用户在home模块刷新的时候，用户信息一直在展示（mounted执行的时候在向服务器发请求、获取用户信息展示）

home->search[用户信息刷新数据就没了，因为在search模块当中根本没有发请求获取用户信息]

search-detail[根本没有获取用户信息进行展示]

解决方法：**导航守卫**



## 2.32 导航守卫

思路：直接看流程图
为什么要判断name？

> 因为store中的token是通过localStorage获取的，token有存放在本地。当页面刷新时，本地token不会消失，所以store中的token也不会消失。但是，store中的其他数据（用户信息等）会清空，此时会出现用户信息不存在，但是有token，这种情况是不可以访问其他页面的，必须先去获取用户信息。由于用户信息是一个对象，所以我们通过它的一个属性name判断用户信息是否存在。
>
> 所以不仅要判断token,还要判断用户信息

![在这里插入图片描述](https://img-blog.csdnimg.cn/5f9936d9914c4aefaa90b20866ba0219.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5q-b5q-b6Jmr5ZGc5ZGc,size_20,color_FFFFFF,t_70,g_se,x_16)

router index.js全局前置守卫代码

```js
//设置全局导航前置守卫
router.beforeEach(async(to, from, next) =>  {
    let token = store.state.user.token
    let name = store.state.user.userInfo.name
    //1、有token代表登录，全部页面放行
    if(token){
        //1.1登陆了，不允许前往登录页
        if(to.path==='/login'){
            next('/home')
        } else{
            //1.2、因为store中的token是通过localStorage获取的，token有存放在本地
            // 当页面刷新时，token不会消失，但是store中的其他数据会清空，
            // 所以不仅要判断token,还要判断用户信息

            //1.2.1、判断仓库中是否有用户信息，有放行，没有派发actions获取信息
            if(name)
                next()
            else{
                //1.2.2、如果没有用户信息，则派发actions获取用户信息
                try{
                    await store.dispatch('getUserInfo')
                    next()
                }catch (error){
                    //1.2.3、获取用户信息失败，原因：token过期
                    //清除前后端token，跳转到登陆页面
                    await store.dispatch('logout')
                    next('/login')
                }
            }
        }
    }else{
        //2、未登录，首页或者登录页可以正常访问
        if(to.path === '/login' || to.path === '/home' || to.path==='/register')
            next()
        else{
            alert('请先登录')
            next('/login')
        }
    }
})
```





## 2.33 交易模块

如果前面的知识你都理解了，后面的模块开发都会比较简单。无非就是老师讲到的开发四步骤
（1）封装API
（2）vuex三件套
（3）dispatch发请求
（4）数据渲染



> **注意：**（3）中，如果在发请求之后还有一些对返回数据的操作，应考虑到是否需要async await。
> 至此，个人认为本项目中的vue前端知识点应该就这些了，后面的相关组件开发，用到的知识在前面都有使用。如果有新知识，会继续更新。



但是，你一定希望将支付二维码换为你自己的二维码！
如果你直接使用项目中的图片,会出现图片损坏的图标。
解决方法：将你的二维码图片放入在博客文章中，然后就可以获取该图片的链接。

```js
data(){
    return{
        payInfo:{},
        //支付二维码
        payImg: 'https://img-blog.csdnimg.cn/6d82f91e804545cc90d9182bc57ea4ad.jpg?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5q-b5q-b6Jmr5ZGc5ZGc,size_19,color_FFFFFF,t_70,g_se,x_16',
        timer:null,//支付定时器
        code: '',//支付状态码
    }},
```

下面代码中涉及到计时器[setInterval()与setTimeout()计时器](https://www.cnblogs.com/lengyuehuahun/p/5650030.html)

```js
//点击支付按钮，弹出支付二维码
async opens(){

    this.$alert(`<img height="200px" width="200px" src="${this.payImg}"  / >`, '请使用微信扫码', {
        dangerouslyUseHTMLString: true,
        showCancelButton: true,
        center: true
    });
    //需要知道订单是否支付成功
    //成功则跳转，失败则提示信息
    if(!this.timer){
        //定时器间歇发送请求获取订单支付状态
        this.timer = setInterval(async ()=>{
            let result = await this.$API.reqGetPayStatus(this.payInfo.orderId)
            console.log(result)
            //因为每次支付都要花钱，所以直接205（支付中）就跳转了，
            if(result.code === 205){
                //1、清除定时器
                clearInterval(this.timer)
                this.timer = null
                //2、保存支付成功返回的code
                this.code = result.code
                //3、关闭弹出框
                this.$msgbox.close()
                //4、跳转到下一个路由
                this.$router.push('/paysuccess')
            }
        },1000)
    }
}

```

效果展示

![在这里插入图片描述](https://img-blog.csdnimg.cn/f6a85b0f887d4de585c77efbbc34014a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5q-b5q-b6Jmr5ZGc5ZGc,size_18,color_FFFFFF,t_70,g_se,x_16)

如果code===200跳转，我们必须支付后台提供的二维码，才会返回200，所以这里直接205就跳转了，后面的支付信息感觉没有意义了。所以，后面的支付内容就不写了。



## **2.34 Vue图片引入**

因为在引入我们个人支付二维码图片遇到了一些问题，所以这里就介绍一下图片引入的方式。

图片引入分两种：js内引入图片，非js内引入图片。

**非js内引入图片（html）**：一般都是通过路径引入，例如：`<img src="../assets/pay.jpg">`。



**js内引入图片**: 可分为通过路径引入和不通过路径引入。

1、如果想要通过**路径方式**在vue中的js引入图片，**必须require引入**。
例如：js中引入个人支付二维码可以通过下面方式实现

```js
this.$alert(`<img height="200px" width="200px" src="${require('@/assets/pay.jpg')}"  / >`, '请使用微信扫码', {
    dangerouslyUseHTMLString: true,
    showCancelButton: true,
    center: true
});
```



2、当然也可以不使用require，如果使用require，就不能通过路径方式引入。有两种方式：
（1）直接引入网页图片链接（前面引入个人收款码就是通过该方法实现）
（2）在< script >中通过import导入图片，然后在js中使用

```html
<script>
    import payImg  from '@/assets/pay.jpg'
    export default {
        methods:{
            //点击支付按钮，弹出支付二维码1
            async opens(){
                this.$alert(`<img height="200px" width="200px" src="${require('@/assets/pay.jpg')}"  / >`, '请使用微信扫码', {
                    dangerouslyUseHTMLString: true,
                    showCancelButton: true,
                    center: true
                });
            }
        }
</script>
```

参考链接：https://blog.csdn.net/ze1024/article/details/108713082





## 2.35 个人中心

终于用到了二级路由，虽然二级路由在后台管理系统常用，但是我们的个人中心也可以用到二级路由。

routers.js
**注意：** 二级路由要么不写/，要么写全：‘/center/myorder’。

```js
//个人中心
    {
        name: 'Center',
        path: '/center',
        component:  () => import('@/pages/Center'),
        children: [
            {
                //二级路由要么不写/，要么写全：'/center/myorder'
                path: 'myorder',
                component: () => import('@/pages/Center/MyOrder')
            },
            {
                path: 'groupbuy',
                component: () => import('@/pages/Center/GroupOrder'),
            },
            //默认显示
            {
                path: '',
                redirect: 'myorder'
            }
        ]
    }

```

`{ path: '', redirect: 'myorder' }`表示当我们访问center路由时，center中的router-view部分默认显示myorder二级路由内容。

我们的子路由最好放在父路由文件夹下，如下所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/cc1f89458d094fdfa8852b930295b13c.png)

**警告**

![在这里插入图片描述](https://img-blog.csdnimg.cn/05eceeda80c449b3b9753c8917b6bcc4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5q-b5q-b6Jmr5ZGc5ZGc,size_20,color_FFFFFF,t_70,g_se,x_16)

图中内容如下：

> Named Route ‘Center’ has a default child route. When navigating to this named route (:to=“{name: ‘Center’”), the default child route will not be rendered. Remove the name from this route and use the name of the default child route for named links instead.



对应的代码

```js
//个人中心
    {
        name: 'Center',
        path: '/center',
        component:  () => import('@/pages/Center'),
        children: [
            {
                //二级路由要么不写/，要么写全：'/center/myorder'
                path: '/center/myorder',
                component: () => import('@/pages/Center/MyOrder')
            },
            {
                path: '/center/groupbuy',
                component: () => import('@/pages/Center/GroupOrder'),
            },
            //默认显示
            {
                path: '',
                redirect: 'myorder'
            }
        ]
    }

```

**总结警告缘由**：当某个路由有子级路由时，父级路由须要一个默认的路由，因此父级路由不能定义name属性，解决办法是去掉name:'Center’就好了。

我的订单部分使用到了之前写的分页器组件，当我再次使用时，我发现我已经快忘记这个分页器怎么写的了。个人觉得需要勤复习之前的知识点。

**老师这个手写的分页器很nice，涉及到一些分页逻辑还有父子双向通信**



## 2.36 路由独享的守卫

全局导航守卫已经帮助我们限制未登录的用户不可以访问相关页面。但是还会有一个问题。

例如：

> 用户已经登陆，用户在home页直接通过地址栏访问trade结算页面，发现可以成功进入该页面，正常情况，用户只能通过在shopcart页面点击去结算按钮才可以到达trade页面。我们可以通过路由独享守卫解决该问题

路由独享的守卫：只针对一个路由的守卫，所以该守卫会定义在某个路由中。

以上面问题为例，我们可以通过路由独享的守卫解决。

在trade路由信息中加入路由独享守卫

```js
//交易组件
    {
        name: 'Trade',
        path: '/trade',
        meta: {show:true},
        component:  () => import('@/pages/Trade'),
        //路由独享首位
        beforeEnter: (to, from, next) => {
          
            if(from.path ===  '/shopcart' ){
                next()
            }else{
                next(false)
            }
        }
    },
```

上面的代码已经实现了trade路由只能从shopcart路由跳转。next(false)指回到from路由。

但是，上面的代码还会有bug，就是当我们在shopcart页面通过地址栏访问trade时还是会成功。正常情况应该是只有当我们点击去结算按钮后才可以进入到trade页面。（这只是我个人观点）

**解决办法：**

在shopcart路由信息**meta**中加一个**flag**，初始值为false。当点击去结算按钮后，将flag置为true。在trade的独享路由守卫中判断一下flag是否为true，当flag为true时，代表是通过点击去结算按钮跳转的，所以就放行。

shopcart路由信息

```js
 //购物车
    {
        path: "/shopcart",
        name: 'ShopCart',
        component: ()=> import('../pages/ShopCart'),
        meta:{show: true,flag: false},
    },
```

shopcart组件去结算按钮触发事件

```js
toTrade(){
    this.$route.meta.flag = true
    this.$router.push('/trade')
}
```

trade路由信息

```js
//交易组件
    {
        name: 'Trade',
        path: '/trade',
        meta: {show:true},
        component:  () => import('@/pages/Trade'),
        //路由独享首位
        beforeEnter: (to, from, next) => {
            if(from.path ===  '/shopcart' && from.meta.flag === true){
                from.meta.flag = false
                next()
            }else{
                next(false)
            }
        }
    },
```

**注意，判断通过后，在跳转之前一定要将flag置为false。**



## 2.37 图片懒加载

懒加载vue-lazyload插件：https://www.npmjs.com/package/vue-lazyload

插件的使用直接参考官方教程，很简单。

### vue使用插件的原理

每个插件都会有一个install方法，install后就可以在我们的代码中可以使用该插件。这个install有两类参数，第一个为Vue实例，后面的参数可以自定义。
vue使用插件的步骤

1、引入插件 import VueLazyload from "vue-lazyload";
2、注册插件Vue.use(VueLazyload)

这里的Vue.use()实际上就是调用了插件的install方法。如此之后，我们就可以使用该插件了。


## 2.38 路由懒加载

原来我一直使用的import()是路由懒加载，哈哈!

当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。

路由懒加载：https://router.vuejs.org/zh/guide/advanced/lazy-loading.html

我还是喜欢下面的写法，不太喜欢官网的写法。

代码示例：

```js
  //详情页面组件
    {
        //需要params传参（产品id）
        path: "/detail/:skuId",
        name: 'Detail',
        component: ()=> import('../pages/Detail'),
        meta:{show: true},
    },
    //添加购物车成功
    {
        path: "/addcartsuccess",
        name: 'AddCartSuccess',
        component: ()=> import('../pages/AddCartSuccess'),
        meta:{show: true},
    },
```





## 2.39 打包项目

项目到此基本就完成了，接下来就是打包上线。在项目文件夹下执行`npm run build`。会生成dist打包文件。

dist就是我们打包好的项目文件

dist文件下的js文件存放我们所有的js文件，并且经过了加密，并且还会生成对应的map文件。

**map文件作用**：因为代码是经过加密的，如果运行时报错，输出的错误信息无法准确得知时那里的代码报错。有了map就可以向未加密的代码一样，准确的输出是哪一行那一列有错。

当然map文件也可以去除（map文件大小还是比较大的）

在vue.config.js配置productionSourceMap: false即可。

注意：vue.config.js配置改变，需要重启项目
